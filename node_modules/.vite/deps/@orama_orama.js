import {
  __export,
  __publicField
} from "./chunk-34KZWS7D.js";

// node_modules/@orama/orama/dist/components/tokenizer/languages.js
var STEMMERS = {
  arabic: "ar",
  armenian: "am",
  bulgarian: "bg",
  danish: "dk",
  dutch: "nl",
  english: "en",
  finnish: "fi",
  french: "fr",
  german: "de",
  greek: "gr",
  hungarian: "hu",
  indian: "in",
  indonesian: "id",
  irish: "ie",
  italian: "it",
  lithuanian: "lt",
  nepali: "np",
  norwegian: "no",
  portuguese: "pt",
  romanian: "ro",
  russian: "ru",
  serbian: "rs",
  slovenian: "ru",
  spanish: "es",
  swedish: "se",
  tamil: "ta",
  turkish: "tr",
  ukrainian: "uk"
};
var SPLITTERS = {
  dutch: /[^A-Za-zàèéìòóù0-9_'-]+/gim,
  english: /[^A-Za-zàèéìòóù0-9_'-]+/gim,
  french: /[^a-z0-9äâàéèëêïîöôùüûœç-]+/gim,
  italian: /[^A-Za-zàèéìòóù0-9_'-]+/gim,
  norwegian: /[^a-z0-9_æøåÆØÅäÄöÖüÜ]+/gim,
  portuguese: /[^a-z0-9à-úÀ-Ú]/gim,
  russian: /[^a-z0-9а-яА-ЯёЁ]+/gim,
  spanish: /[^a-z0-9A-Zá-úÁ-ÚñÑüÜ]+/gim,
  swedish: /[^a-z0-9_åÅäÄöÖüÜ-]+/gim,
  german: /[^a-z0-9A-ZäöüÄÖÜß]+/gim,
  finnish: /[^a-z0-9äöÄÖ]+/gim,
  danish: /[^a-z0-9æøåÆØÅ]+/gim,
  hungarian: /[^a-z0-9áéíóöőúüűÁÉÍÓÖŐÚÜŰ]+/gim,
  romanian: /[^a-z0-9ăâîșțĂÂÎȘȚ]+/gim,
  serbian: /[^a-z0-9čćžšđČĆŽŠĐ]+/gim,
  turkish: /[^a-z0-9çÇğĞıİöÖşŞüÜ]+/gim,
  lithuanian: /[^a-z0-9ąčęėįšųūžĄČĘĖĮŠŲŪŽ]+/gim,
  arabic: /[^a-z0-9أ-ي]+/gim,
  nepali: /[^a-z0-9अ-ह]+/gim,
  irish: /[^a-z0-9áéíóúÁÉÍÓÚ]+/gim,
  indian: /[^a-z0-9अ-ह]+/gim,
  armenian: /[^a-z0-9ա-ֆ]+/gim,
  greek: /[^a-z0-9α-ωά-ώ]+/gim,
  indonesian: /[^a-z0-9]+/gim,
  ukrainian: /[^a-z0-9а-яА-ЯіїєІЇЄ]+/gim,
  slovenian: /[^a-z0-9čžšČŽŠ]+/gim,
  bulgarian: /[^a-z0-9а-яА-Я]+/gim,
  tamil: /[^a-z0-9அ-ஹ]+/gim
};
var SUPPORTED_LANGUAGES = Object.keys(STEMMERS);

// node_modules/@orama/orama/dist/utils.js
var baseId = Date.now().toString().slice(5);
var lastId = 0;
var k = 1024;
var nano = BigInt(1e3);
var milli = BigInt(1e6);
var second = BigInt(1e9);
function sprintf(template, ...args) {
  return template.replace(/%(?:(?<position>\d+)\$)?(?<width>-?\d*\.?\d*)(?<type>[dfs])/g, function(...replaceArgs) {
    const groups = replaceArgs[replaceArgs.length - 1];
    const { width: rawWidth, type, position } = groups;
    const replacement = position ? args[Number.parseInt(position) - 1] : args.shift();
    const width = rawWidth === "" ? 0 : Number.parseInt(rawWidth);
    switch (type) {
      case "d":
        return replacement.toString().padStart(width, "0");
      case "f": {
        let value = replacement;
        const [padding, precision] = rawWidth.split(".").map((w) => Number.parseFloat(w));
        if (typeof precision === "number" && precision >= 0) {
          value = value.toFixed(precision);
        }
        return typeof padding === "number" && padding >= 0 ? value.toString().padStart(width, "0") : value.toString();
      }
      case "s":
        return width < 0 ? replacement.toString().padEnd(-width, " ") : replacement.toString().padStart(width, " ");
      default:
        return replacement;
    }
  });
}
async function formatBytes(bytes, decimals = 2) {
  if (bytes === 0) {
    return "0 Bytes";
  }
  const dm = decimals < 0 ? 0 : decimals;
  const sizes = [
    "Bytes",
    "KB",
    "MB",
    "GB",
    "TB",
    "PB",
    "EB",
    "ZB",
    "YB"
  ];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`;
}
async function formatNanoseconds(value) {
  if (typeof value === "number") {
    value = BigInt(value);
  }
  if (value < nano) {
    return `${value}ns`;
  } else if (value < milli) {
    return `${value / nano}μs`;
  } else if (value < second) {
    return `${value / milli}ms`;
  }
  return `${value / second}s`;
}
async function getNanosecondsTime() {
  if (typeof process !== "undefined" && process.hrtime !== void 0) {
    return process.hrtime.bigint();
  }
  if (typeof performance !== "undefined") {
    return BigInt(Math.floor(performance.now() * 1e6));
  }
  return BigInt(0);
}
async function uniqueId() {
  return `${baseId}-${lastId++}`;
}
function getOwnProperty(object, property) {
  if (Object.hasOwn === void 0) {
    return Object.prototype.hasOwnProperty.call(object, property) ? object[property] : void 0;
  }
  return Object.hasOwn(object, property) ? object[property] : void 0;
}
function sortTokenScorePredicate(a, b) {
  if (b[1] === a[1]) {
    return a[0] - b[0];
  }
  return b[1] - a[1];
}
function intersect(arrays) {
  if (arrays.length === 0) {
    return [];
  } else if (arrays.length === 1) {
    return arrays[0];
  }
  for (let i = 1; i < arrays.length; i++) {
    if (arrays[i].length < arrays[0].length) {
      const tmp = arrays[0];
      arrays[0] = arrays[i];
      arrays[i] = tmp;
    }
  }
  const set = /* @__PURE__ */ new Map();
  for (const elem of arrays[0]) {
    set.set(elem, 1);
  }
  for (let i = 1; i < arrays.length; i++) {
    let found = 0;
    for (const elem of arrays[i]) {
      const count3 = set.get(elem);
      if (count3 === i) {
        set.set(elem, count3 + 1);
        found++;
      }
    }
    if (found === 0)
      return [];
  }
  return arrays[0].filter((e) => {
    const count3 = set.get(e);
    if (count3 !== void 0)
      set.set(e, 0);
    return count3 === arrays.length;
  });
}
async function getDocumentProperties(doc, paths) {
  const properties = {};
  const pathsLength = paths.length;
  for (let i = 0; i < pathsLength; i++) {
    const path = paths[i];
    const pathTokens = path.split(".");
    let current = doc;
    const pathTokensLength = pathTokens.length;
    for (let j = 0; j < pathTokensLength; j++) {
      current = current[pathTokens[j]];
      if (typeof current === "object" && !Array.isArray(current) && current !== null && j === pathTokensLength - 1) {
        current = void 0;
        break;
      } else if ((current === null || typeof current !== "object") && j < pathTokensLength - 1) {
        current = void 0;
        break;
      }
    }
    if (typeof current !== "undefined") {
      properties[path] = current;
    }
  }
  return properties;
}
async function getNested(obj, path) {
  const props = await getDocumentProperties(obj, [
    path
  ]);
  return props[path];
}

// node_modules/@orama/orama/dist/errors.js
var allLanguages = SUPPORTED_LANGUAGES.join("\n - ");
var errors = {
  NO_LANGUAGE_WITH_CUSTOM_TOKENIZER: "Do not pass the language option to create when using a custom tokenizer.",
  LANGUAGE_NOT_SUPPORTED: `Language "%s" is not supported.
Supported languages are:
 - ${allLanguages}`,
  INVALID_STEMMER_FUNCTION_TYPE: `config.stemmer property must be a function.`,
  MISSING_STEMMER: `As of version 1.0.0 @orama/orama does not ship non English stemmers by default. To solve this, please explicitly import and specify the "%s" stemmer from the package @orama/stemmers. See https://docs.oramasearch.com/text-analysis/stemming for more information.`,
  CUSTOM_STOP_WORDS_MUST_BE_FUNCTION_OR_ARRAY: "Custom stop words array must only contain strings.",
  UNSUPPORTED_COMPONENT: `Unsupported component "%s".`,
  COMPONENT_MUST_BE_FUNCTION: `The component "%s" must be a function.`,
  COMPONENT_MUST_BE_FUNCTION_OR_ARRAY_FUNCTIONS: `The component "%s" must be a function or an array of functions.`,
  INVALID_SCHEMA_TYPE: `Unsupported schema type "%s" at "%s". Expected "string", "boolean" or "number" or array of them.`,
  DOCUMENT_ID_MUST_BE_STRING: `Document id must be of type "string". Got "%s" instead.`,
  DOCUMENT_ALREADY_EXISTS: `A document with id "%s" already exists.`,
  DOCUMENT_DOES_NOT_EXIST: `A document with id "%s" does not exists.`,
  MISSING_DOCUMENT_PROPERTY: `Missing searchable property "%s".`,
  INVALID_DOCUMENT_PROPERTY: `Invalid document property "%s": expected "%s", got "%s"`,
  UNKNOWN_INDEX: `Invalid property name "%s". Expected a wildcard string ("*") or array containing one of the following properties: %s`,
  INVALID_BOOST_VALUE: `Boost value must be a number greater than, or less than 0.`,
  INVALID_FILTER_OPERATION: `You can only use one operation per filter, you requested %d.`,
  SCHEMA_VALIDATION_FAILURE: `Cannot insert document due schema validation failure on "%s" property.`,
  INVALID_SORT_SCHEMA_TYPE: `Unsupported sort schema type "%s" at "%s". Expected "string" or "number".`,
  CANNOT_SORT_BY_ARRAY: `Cannot configure sort for "%s" because it is an array (%s).`,
  UNABLE_TO_SORT_ON_UNKNOWN_FIELD: `Unable to sort on unknown field "%s". Allowed fields: %s`,
  SORT_DISABLED: `Sort is disabled. Please read the documentation at https://docs.oramasearch for more information.`,
  UNKNOWN_GROUP_BY_PROPERTY: `Unknown groupBy property "%s".`,
  INVALID_GROUP_BY_PROPERTY: `Invalid groupBy property "%s". Allowed types: "%s", but given "%s".`,
  UNKNOWN_FILTER_PROPERTY: `Unknown filter property "%s".`
};
function createError(code, ...args) {
  const error = new Error(sprintf(errors[code] ?? `Unsupported Orama Error code: ${code}`, ...args));
  error.code = code;
  if ("captureStackTrace" in Error.prototype) {
    Error.captureStackTrace(error);
  }
  return error;
}

// node_modules/@orama/orama/dist/components/defaults.js
async function formatElapsedTime(n) {
  return {
    raw: Number(n),
    formatted: await formatNanoseconds(n)
  };
}
async function getDocumentIndexId(doc) {
  if (doc.id) {
    if (typeof doc.id !== "string") {
      throw createError("DOCUMENT_ID_MUST_BE_STRING", typeof doc.id);
    }
    return doc.id;
  }
  return await uniqueId();
}
async function validateSchema(doc, schema) {
  for (const [prop, type] of Object.entries(schema)) {
    const value = doc[prop];
    const typeOfValue = typeof value;
    if (typeOfValue === "undefined") {
      continue;
    }
    const typeOfType = typeof type;
    if (typeOfType === "string" && isArrayType(type)) {
      if (!Array.isArray(value)) {
        return prop;
      }
      const expectedType = getInnerType(type);
      const valueLength = value.length;
      for (let i = 0; i < valueLength; i++) {
        if (typeof value[i] !== expectedType) {
          return prop + "." + i;
        }
      }
      continue;
    }
    if (typeOfType === "object") {
      if (!value || typeOfValue !== "object") {
        return prop;
      }
      const subProp = await validateSchema(value, type);
      if (subProp) {
        return prop + "." + subProp;
      }
      continue;
    }
    if (typeOfValue !== type) {
      return prop;
    }
  }
  return void 0;
}
var IS_ARRAY_TYPE = {
  string: false,
  number: false,
  boolean: false,
  "string[]": true,
  "number[]": true,
  "boolean[]": true
};
var INNER_TYPE = {
  "string[]": "string",
  "number[]": "number",
  "boolean[]": "boolean"
};
function isArrayType(type) {
  return IS_ARRAY_TYPE[type];
}
function getInnerType(type) {
  return INNER_TYPE[type];
}

// node_modules/@orama/orama/dist/components/documents-store.js
var documents_store_exports = {};
__export(documents_store_exports, {
  count: () => count,
  create: () => create,
  createDocumentsStore: () => createDocumentsStore,
  get: () => get,
  getAll: () => getAll,
  getMultiple: () => getMultiple,
  load: () => load2,
  remove: () => remove,
  save: () => save2,
  store: () => store
});

// node_modules/@orama/orama/dist/components/internal-document-id-store.js
var internal_document_id_store_exports = {};
__export(internal_document_id_store_exports, {
  createInternalDocumentIDStore: () => createInternalDocumentIDStore,
  getDocumentIdFromInternalId: () => getDocumentIdFromInternalId,
  getInternalDocumentId: () => getInternalDocumentId,
  load: () => load,
  save: () => save
});
function createInternalDocumentIDStore() {
  return {
    idToInternalId: /* @__PURE__ */ new Map(),
    internalIdToId: [],
    save,
    load
  };
}
function save(store2) {
  return {
    internalIdToId: store2.internalIdToId
  };
}
function load(orama, raw) {
  const { internalIdToId } = raw;
  orama.internalDocumentIDStore.idToInternalId.clear();
  orama.internalDocumentIDStore.internalIdToId = [];
  for (let i = 0; i < internalIdToId.length; i++) {
    orama.internalDocumentIDStore.idToInternalId.set(internalIdToId[i], i + 1);
    orama.internalDocumentIDStore.internalIdToId.push(internalIdToId[i]);
  }
}
function getInternalDocumentId(store2, id) {
  if (typeof id === "string") {
    const internalId = store2.idToInternalId.get(id);
    if (internalId) {
      return internalId;
    }
    const currentId = store2.idToInternalId.size + 1;
    store2.idToInternalId.set(id, currentId);
    store2.internalIdToId.push(id);
    return currentId;
  }
  if (id > store2.internalIdToId.length) {
    return getInternalDocumentId(store2, id.toString());
  }
  return id;
}
function getDocumentIdFromInternalId(store2, internalId) {
  if (store2.internalIdToId.length < internalId) {
    throw new Error(`Invalid internalId ${internalId}`);
  }
  return store2.internalIdToId[internalId - 1];
}

// node_modules/@orama/orama/dist/components/documents-store.js
async function create(_, sharedInternalDocumentStore) {
  return {
    sharedInternalDocumentStore,
    docs: {},
    count: 0
  };
}
async function get(store2, id) {
  const internalId = getInternalDocumentId(store2.sharedInternalDocumentStore, id);
  return store2.docs[internalId];
}
async function getMultiple(store2, ids) {
  const found = Array.from({
    length: ids.length
  });
  for (let i = 0; i < ids.length; i++) {
    const internalId = getInternalDocumentId(store2.sharedInternalDocumentStore, ids[i]);
    found[i] = store2.docs[internalId];
  }
  return found;
}
async function getAll(store2) {
  return store2.docs;
}
async function store(store2, id, doc) {
  const internalId = getInternalDocumentId(store2.sharedInternalDocumentStore, id);
  if (typeof store2.docs[internalId] !== "undefined") {
    return false;
  }
  store2.docs[internalId] = doc;
  store2.count++;
  return true;
}
async function remove(store2, id) {
  const internalId = getInternalDocumentId(store2.sharedInternalDocumentStore, id);
  if (typeof store2.docs[internalId] === "undefined") {
    return false;
  }
  delete store2.docs[internalId];
  store2.count--;
  return true;
}
async function count(store2) {
  return store2.count;
}
async function load2(sharedInternalDocumentStore, raw) {
  const rawDocument = raw;
  return {
    docs: rawDocument.docs,
    count: rawDocument.count,
    sharedInternalDocumentStore
  };
}
async function save2(store2) {
  return {
    docs: store2.docs,
    count: store2.count
  };
}
async function createDocumentsStore() {
  return {
    create,
    get,
    getMultiple,
    getAll,
    store,
    remove,
    count,
    load: load2,
    save: save2
  };
}

// node_modules/@orama/orama/dist/components/hooks.js
var OBJECT_COMPONENTS = [
  "tokenizer",
  "index",
  "documentsStore",
  "sorter"
];
var FUNCTION_COMPONENTS = [
  "validateSchema",
  "getDocumentIndexId",
  "getDocumentProperties",
  "formatElapsedTime"
];
var SINGLE_OR_ARRAY_COMPONENTS = [
  "beforeInsert",
  "afterInsert",
  "beforeRemove",
  "afterRemove",
  "beforeUpdate",
  "afterUpdate",
  "afterSearch",
  "beforeMultipleInsert",
  "afterMultipleInsert",
  "beforeMultipleRemove",
  "afterMultipleRemove",
  "beforeMultipleUpdate",
  "afterMultipleUpdate"
];
async function runSingleHook(hooks, orama, id, doc) {
  const hooksLength = hooks.length;
  for (let i = 0; i < hooksLength; i++) {
    await hooks[i](orama, id, doc);
  }
}
async function runMultipleHook(hooks, orama, docsOrIds) {
  const hooksLength = hooks.length;
  for (let i = 0; i < hooksLength; i++) {
    await hooks[i](orama, docsOrIds);
  }
}
async function runAfterSearch(hooks, db, params, language, results) {
  const hooksLength = hooks.length;
  for (let i = 0; i < hooksLength; i++) {
    await hooks[i](db, params, language, results);
  }
}

// node_modules/@orama/orama/dist/components/index.js
var components_exports = {};
__export(components_exports, {
  calculateResultScores: () => calculateResultScores,
  create: () => create4,
  createIndex: () => createIndex,
  getSearchableProperties: () => getSearchableProperties,
  getSearchablePropertiesWithTypes: () => getSearchablePropertiesWithTypes,
  insert: () => insert3,
  insertDocumentScoreParameters: () => insertDocumentScoreParameters,
  insertTokenScoreParameters: () => insertTokenScoreParameters,
  load: () => load3,
  remove: () => remove3,
  removeDocumentScoreParameters: () => removeDocumentScoreParameters,
  removeTokenScoreParameters: () => removeTokenScoreParameters,
  save: () => save3,
  search: () => search,
  searchByWhereClause: () => searchByWhereClause
});

// node_modules/@orama/orama/dist/trees/avl.js
var avl_exports = {};
__export(avl_exports, {
  contains: () => contains,
  create: () => create2,
  find: () => find,
  getSize: () => getSize,
  greaterThan: () => greaterThan,
  insert: () => insert,
  isBalanced: () => isBalanced,
  lessThan: () => lessThan,
  rangeSearch: () => rangeSearch,
  remove: () => remove2,
  removeDocument: () => removeDocument
});
var BALANCE_STATE = {
  UNBALANCED_RIGHT: -2,
  SLIGHTLY_UNBALANCED_RIGHT: -1,
  BALANCED: 0,
  SLIGHTLY_UNBALANCED_LEFT: 1,
  UNBALANCED_LEFT: 2
};
function getHeight(node) {
  return node ? node.height : -1;
}
function rotateLeft(node) {
  const right = node.right;
  node.right = right.left;
  right.left = node;
  node.height = Math.max(getHeight(node.left), getHeight(node.right)) + 1;
  right.height = Math.max(getHeight(right.left), getHeight(right.right)) + 1;
  return right;
}
function rotateRight(node) {
  const left = node.left;
  node.left = left.right;
  left.right = node;
  node.height = Math.max(getHeight(node.left), getHeight(node.right)) + 1;
  left.height = Math.max(getHeight(left.left), getHeight(left.right)) + 1;
  return left;
}
function contains(node, key) {
  return !!find(node, key);
}
function getSize(root) {
  let size = 0;
  const queue = [];
  if (root !== null) {
    queue.push(root);
  }
  while (queue.length > 0) {
    const node = queue.shift();
    size++;
    if (node.left !== null) {
      queue.push(node.left);
    }
    if (node.right !== null) {
      queue.push(node.right);
    }
  }
  return size;
}
function isBalanced(root) {
  if (root === null)
    return true;
  const stack = [
    root
  ];
  while (stack.length > 0) {
    const node = stack.pop();
    if (node === void 0)
      return true;
    const heightDiff = getHeight(node.left) - getHeight(node.right);
    if (heightDiff > 1 || heightDiff < -1) {
      return false;
    }
    if (node.right !== null) {
      stack.push(node.right);
    }
    if (node.left !== null) {
      stack.push(node.left);
    }
  }
  return true;
}
function rangeSearch(node, min, max) {
  if (!node) {
    return [];
  }
  const result = [];
  function traverse(node2) {
    if (!node2) {
      return;
    }
    if (node2.key > min) {
      traverse(node2.left);
    }
    if (node2.key >= min && node2.key <= max) {
      result.push(...node2.value);
    }
    if (node2.key < max) {
      traverse(node2.right);
    }
  }
  traverse(node);
  return result;
}
function greaterThan(node, key, inclusive = false) {
  if (!node) {
    return [];
  }
  const result = [];
  function traverse(node2) {
    if (!node2) {
      return;
    }
    if (inclusive && node2.key >= key) {
      result.push(...node2.value);
    }
    if (!inclusive && node2.key > key) {
      result.push(...node2.value);
    }
    traverse(node2.left);
    traverse(node2.right);
  }
  traverse(node);
  return result;
}
function lessThan(node, key, inclusive = false) {
  if (!node) {
    return [];
  }
  const result = [];
  function traverse(node2) {
    if (!node2) {
      return;
    }
    if (inclusive && node2.key <= key) {
      result.push(...node2.value);
    }
    if (!inclusive && node2.key < key) {
      result.push(...node2.value);
    }
    traverse(node2.left);
    traverse(node2.right);
  }
  traverse(node);
  return result;
}
function getNodeByKey(node, key) {
  while (node !== null) {
    if (key < node.key) {
      node = node.left;
    } else if (key > node.key) {
      node = node.right;
    } else {
      return node;
    }
  }
  return null;
}
function create2(key, value) {
  return {
    key,
    value,
    left: null,
    right: null,
    height: 0
  };
}
function insert(root, key, value) {
  let parent = null;
  let current = root;
  while (current !== null) {
    parent = current;
    if (key < current.key) {
      current = current.left;
    } else if (key > current.key) {
      current = current.right;
    } else {
      current.value = current.value.concat(value);
      return root;
    }
  }
  const newNode = create2(key, value);
  if (!parent) {
    root = newNode;
  } else if (key < parent.key) {
    parent.left = newNode;
  } else {
    parent.right = newNode;
  }
  current = newNode;
  while (parent) {
    const balanceFactor = getHeight(parent.left) - getHeight(parent.right);
    if (balanceFactor === BALANCE_STATE.UNBALANCED_LEFT) {
      if (key > parent.left.key) {
        parent.left = rotateLeft(parent.left);
      }
      parent = rotateRight(parent);
    }
    if (balanceFactor === BALANCE_STATE.UNBALANCED_RIGHT) {
      if (key < parent.right.key) {
        parent.right = rotateRight(parent.right);
      }
      parent = rotateLeft(parent);
    }
    if (parent === root) {
      break;
    }
    current = parent;
    parent = getNodeParent(root, current.key);
  }
  return root;
}
function getNodeParent(root, key) {
  let current = root;
  let parent = null;
  while (current !== null) {
    if (key < current.key) {
      parent = current;
      current = current.left;
    } else if (key > current.key) {
      parent = current;
      current = current.right;
    } else {
      break;
    }
  }
  return parent;
}
function find(root, key) {
  const node = getNodeByKey(root, key);
  if (!node) {
    return null;
  }
  return node.value;
}
function remove2(root, key) {
  let node = root;
  let parentNode = null;
  while (node && node.key !== key) {
    parentNode = node;
    if (key < node.key) {
      node = node.left;
    } else {
      node = node.right;
    }
  }
  if (!node) {
    return null;
  }
  if (!node.left && !node.right) {
    if (!parentNode) {
      root = null;
    } else {
      if (parentNode.left === node) {
        parentNode.left = null;
      } else {
        parentNode.right = null;
      }
    }
  } else if (node.left && node.right) {
    let minValueNode = node.right;
    let minValueParent = node;
    while (minValueNode.left) {
      minValueParent = minValueNode;
      minValueNode = minValueNode.left;
    }
    node.key = minValueNode.key;
    if (minValueParent === node) {
      minValueParent.right = minValueNode.right;
    } else {
      minValueParent.left = minValueNode.right;
    }
  } else {
    const childNode = node.left ? node.left : node.right;
    if (!parentNode) {
      root = childNode;
    } else {
      if (parentNode.left === node) {
        parentNode.left = childNode;
      } else {
        parentNode.right = childNode;
      }
    }
  }
  return root;
}
function removeDocument(root, id, key) {
  const node = getNodeByKey(root, key);
  if (node.value.length === 1) {
    remove2(root, key);
    return;
  }
  node.value.splice(node.value.indexOf(id), 1);
}

// node_modules/@orama/orama/dist/trees/radix.js
var radix_exports = {};
__export(radix_exports, {
  Node: () => Node,
  contains: () => contains2,
  create: () => create3,
  find: () => find2,
  insert: () => insert2,
  removeDocumentByWord: () => removeDocumentByWord,
  removeWord: () => removeWord
});

// node_modules/@orama/orama/dist/components/levenshtein.js
function _boundedLevenshtein(a, b, tolerance) {
  if (a === b) {
    return 0;
  }
  const swap = a;
  if (a.length > b.length) {
    a = b;
    b = swap;
  }
  let lenA = a.length;
  let lenB = b.length;
  while (lenA > 0 && a.charCodeAt(~-lenA) === b.charCodeAt(~-lenB)) {
    lenA--;
    lenB--;
  }
  if (!lenA) {
    return lenB > tolerance ? -1 : lenB;
  }
  let startIdx = 0;
  while (startIdx < lenA && a.charCodeAt(startIdx) === b.charCodeAt(startIdx)) {
    startIdx++;
  }
  lenA -= startIdx;
  lenB -= startIdx;
  if (lenA === 0) {
    return lenB > tolerance ? -1 : lenB;
  }
  const delta = lenB - lenA;
  if (tolerance > lenB) {
    tolerance = lenB;
  } else if (delta > tolerance) {
    return -1;
  }
  let i = 0;
  const row = [];
  const characterCodeCache = [];
  while (i < tolerance) {
    characterCodeCache[i] = b.charCodeAt(startIdx + i);
    row[i] = ++i;
  }
  while (i < lenB) {
    characterCodeCache[i] = b.charCodeAt(startIdx + i);
    row[i++] = tolerance + 1;
  }
  const offset = tolerance - delta;
  const haveMax = tolerance < lenB;
  let jStart = 0;
  let jEnd = tolerance;
  let current = 0;
  let left = 0;
  let above = 0;
  let charA = 0;
  let j = 0;
  for (i = 0; i < lenA; i++) {
    left = i;
    current = i + 1;
    charA = a.charCodeAt(startIdx + i);
    jStart += i > offset ? 1 : 0;
    jEnd += jEnd < lenB ? 1 : 0;
    for (j = jStart; j < jEnd; j++) {
      above = current;
      current = left;
      left = row[j];
      if (charA !== characterCodeCache[j]) {
        if (left < current) {
          current = left;
        }
        if (above < current) {
          current = above;
        }
        current++;
      }
      row[j] = current;
    }
    if (haveMax && row[i + delta] > tolerance) {
      return -1;
    }
  }
  return current <= tolerance ? current : -1;
}
async function boundedLevenshtein(a, b, tolerance) {
  const distance = _boundedLevenshtein(a, b, tolerance);
  return {
    distance,
    isBounded: distance >= 0
  };
}
function syncBoundedLevenshtein(a, b, tolerance) {
  const distance = _boundedLevenshtein(a, b, tolerance);
  return {
    distance,
    isBounded: distance >= 0
  };
}

// node_modules/@orama/orama/dist/trees/radix.js
var Node = class {
  constructor(key, subWord, end) {
    __publicField(this, "children", {});
    __publicField(this, "docs", []);
    __publicField(this, "word", "");
    this.key = key;
    this.subWord = subWord;
    this.end = end;
  }
  toJSON() {
    return {
      word: this.word,
      subWord: this.subWord,
      children: this.children,
      docs: this.docs,
      end: this.end
    };
  }
};
function updateParent(node, parent) {
  node.word = parent.word + node.subWord;
}
function addDocument(node, docID) {
  node.docs.push(docID);
}
function removeDocument2(node, docID) {
  const index = node.docs.indexOf(docID);
  if (index === -1) {
    return false;
  }
  node.docs.splice(index, 1);
  return true;
}
function findAllWords(node, output, term, exact, tolerance) {
  if (node.end) {
    const { word, docs: docIDs } = node;
    if (exact && word !== term) {
      return {};
    }
    if (!getOwnProperty(output, word)) {
      if (tolerance) {
        const difference = Math.abs(term.length - word.length);
        if (difference <= tolerance && syncBoundedLevenshtein(term, word, tolerance).isBounded) {
          output[word] = [];
        }
      } else {
        output[word] = [];
      }
    }
    if (getOwnProperty(output, word) && docIDs.length) {
      const docs = new Set(output[word]);
      const docIDsLength = docIDs.length;
      for (let i = 0; i < docIDsLength; i++) {
        docs.add(docIDs[i]);
      }
      output[word] = Array.from(docs);
    }
  }
  for (const character of Object.keys(node.children)) {
    findAllWords(node.children[character], output, term, exact, tolerance);
  }
  return output;
}
function getCommonPrefix(a, b) {
  let commonPrefix = "";
  const len = Math.min(a.length, b.length);
  for (let i = 0; i < len; i++) {
    if (a[i] !== b[i]) {
      return commonPrefix;
    }
    commonPrefix += a[i];
  }
  return commonPrefix;
}
function create3(end = false, subWord = "", key = "") {
  return new Node(key, subWord, end);
}
function insert2(root, word, docId) {
  for (let i = 0; i < word.length; i++) {
    const currentCharacter = word[i];
    const wordAtIndex = word.substring(i);
    const rootChildCurrentChar = root.children[currentCharacter];
    if (rootChildCurrentChar) {
      const edgeLabel = rootChildCurrentChar.subWord;
      const edgeLabelLength = edgeLabel.length;
      const commonPrefix = getCommonPrefix(edgeLabel, wordAtIndex);
      const commonPrefixLength = commonPrefix.length;
      if (edgeLabel === wordAtIndex) {
        addDocument(rootChildCurrentChar, docId);
        rootChildCurrentChar.end = true;
        return;
      }
      const edgeLabelAtCommonPrefix = edgeLabel[commonPrefixLength];
      if (commonPrefixLength < edgeLabelLength && commonPrefixLength === wordAtIndex.length) {
        const newNode = create3(true, wordAtIndex, currentCharacter);
        newNode.children[edgeLabelAtCommonPrefix] = rootChildCurrentChar;
        const newNodeChild = newNode.children[edgeLabelAtCommonPrefix];
        newNodeChild.subWord = edgeLabel.substring(commonPrefixLength);
        newNodeChild.key = edgeLabelAtCommonPrefix;
        root.children[currentCharacter] = newNode;
        updateParent(newNode, root);
        updateParent(newNodeChild, newNode);
        addDocument(newNode, docId);
        return;
      }
      if (commonPrefixLength < edgeLabelLength && commonPrefixLength < wordAtIndex.length) {
        const inbetweenNode = create3(false, commonPrefix, currentCharacter);
        inbetweenNode.children[edgeLabelAtCommonPrefix] = rootChildCurrentChar;
        root.children[currentCharacter] = inbetweenNode;
        const inbetweenNodeChild = inbetweenNode.children[edgeLabelAtCommonPrefix];
        inbetweenNodeChild.subWord = edgeLabel.substring(commonPrefixLength);
        inbetweenNodeChild.key = edgeLabelAtCommonPrefix;
        const wordAtCommonPrefix = wordAtIndex[commonPrefixLength];
        const newNode = create3(true, word.substring(i + commonPrefixLength), wordAtCommonPrefix);
        addDocument(newNode, docId);
        inbetweenNode.children[wordAtCommonPrefix] = newNode;
        updateParent(inbetweenNode, root);
        updateParent(newNode, inbetweenNode);
        updateParent(inbetweenNodeChild, inbetweenNode);
        return;
      }
      i += edgeLabelLength - 1;
      root = rootChildCurrentChar;
    } else {
      const newNode = create3(true, wordAtIndex, currentCharacter);
      addDocument(newNode, docId);
      root.children[currentCharacter] = newNode;
      updateParent(newNode, root);
      return;
    }
  }
}
function find2(root, { term, exact, tolerance }) {
  for (let i = 0; i < term.length; i++) {
    const character = term[i];
    if (character in root.children) {
      const rootChildCurrentChar = root.children[character];
      const edgeLabel = rootChildCurrentChar.subWord;
      const termSubstring = term.substring(i);
      const commonPrefix = getCommonPrefix(edgeLabel, termSubstring);
      const commonPrefixLength = commonPrefix.length;
      if (commonPrefixLength !== edgeLabel.length && commonPrefixLength !== termSubstring.length) {
        if (tolerance)
          break;
        return {};
      }
      i += rootChildCurrentChar.subWord.length - 1;
      root = rootChildCurrentChar;
    } else {
      return {};
    }
  }
  const output = {};
  findAllWords(root, output, term, exact, tolerance);
  return output;
}
function contains2(root, term) {
  for (let i = 0; i < term.length; i++) {
    const character = term[i];
    if (character in root.children) {
      const rootChildrenChar = root.children[character];
      const edgeLabel = rootChildrenChar.subWord;
      const termSubstring = term.substring(i);
      const commonPrefix = getCommonPrefix(edgeLabel, termSubstring);
      const commonPrefixLength = commonPrefix.length;
      if (commonPrefixLength !== edgeLabel.length && commonPrefixLength !== termSubstring.length) {
        return false;
      }
      i += rootChildrenChar.subWord.length - 1;
      root = rootChildrenChar;
    } else {
      return false;
    }
  }
  return true;
}
function removeWord(root, term) {
  if (!term) {
    return false;
  }
  for (let i = 0; i < term.length; i++) {
    const character = term[i];
    const parent = root;
    if (character in root.children) {
      i += root.children[character].subWord.length - 1;
      root = root.children[character];
      if (Object.keys(root.children).length === 0) {
        delete parent.children[root.key];
        return true;
      }
    } else {
      return false;
    }
  }
  return false;
}
function removeDocumentByWord(root, term, docID, exact = true) {
  if (!term) {
    return true;
  }
  for (let i = 0; i < term.length; i++) {
    const character = term[i];
    if (character in root.children) {
      const rootChildCurrentChar = root.children[character];
      i += rootChildCurrentChar.subWord.length - 1;
      root = rootChildCurrentChar;
      if (exact && root.word !== term) {
      } else {
        removeDocument2(root, docID);
      }
    } else {
      return false;
    }
  }
  return true;
}

// node_modules/@orama/orama/dist/components/algorithms.js
function prioritizeTokenScores(arrays, boost, threshold = 1, keywordsCount) {
  if (boost === 0) {
    throw createError("INVALID_BOOST_VALUE");
  }
  const tokenScoresMap = /* @__PURE__ */ new Map();
  const tokenKeywordsCountMap = /* @__PURE__ */ new Map();
  const mapsLength = arrays.length;
  for (let i = 0; i < mapsLength; i++) {
    const arr = arrays[i];
    const entriesLength = arr.length;
    for (let j = 0; j < entriesLength; j++) {
      const [token, score] = arr[j];
      const boostScore = score * boost;
      const oldScore = tokenScoresMap.get(token);
      if (oldScore !== void 0) {
        tokenScoresMap.set(token, oldScore * 1.5 + boostScore);
        tokenKeywordsCountMap.set(token, tokenKeywordsCountMap.get(token) + 1);
      } else {
        tokenScoresMap.set(token, boostScore);
        tokenKeywordsCountMap.set(token, 1);
      }
    }
  }
  const tokenScores = [];
  for (const tokenScoreEntry of tokenScoresMap.entries()) {
    tokenScores.push(tokenScoreEntry);
  }
  const results = tokenScores.sort((a, b) => b[1] - a[1]);
  if (threshold === 1) {
    return results;
  }
  const allResults = results.length;
  const tokenKeywordsCount = [];
  for (const tokenKeywordsCountEntry of tokenKeywordsCountMap.entries()) {
    tokenKeywordsCount.push(tokenKeywordsCountEntry);
  }
  const keywordsPerToken = tokenKeywordsCount.sort((a, b) => b[1] - a[1]);
  let lastTokenWithAllKeywords = void 0;
  for (let i = 0; i < allResults; i++) {
    if (keywordsPerToken[i][1] === keywordsCount) {
      lastTokenWithAllKeywords = i;
    } else {
      break;
    }
  }
  if (typeof lastTokenWithAllKeywords === "undefined") {
    if (threshold === 0) {
      return [];
    }
    lastTokenWithAllKeywords = 0;
  }
  if (threshold === 0) {
    return results.slice(0, lastTokenWithAllKeywords + 1);
  }
  const thresholdLength = lastTokenWithAllKeywords + Math.ceil(threshold * 100 * (results.length - lastTokenWithAllKeywords) / 100);
  return results.slice(0, results.length + thresholdLength);
}
function BM25(tf, matchingCount, docsCount, fieldLength, averageFieldLength, BM25Params) {
  const { k: k2, b, d } = BM25Params;
  const idf = Math.log(1 + (docsCount - matchingCount + 0.5) / (matchingCount + 0.5));
  return idf * (d + tf * (k2 + 1)) / (tf + k2 * (1 - b + b * fieldLength / averageFieldLength));
}

// node_modules/@orama/orama/dist/components/index.js
async function insertDocumentScoreParameters(index, prop, id, tokens, docsCount) {
  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id);
  index.avgFieldLength[prop] = ((index.avgFieldLength[prop] ?? 0) * (docsCount - 1) + tokens.length) / docsCount;
  index.fieldLengths[prop][internalId] = tokens.length;
  index.frequencies[prop][internalId] = {};
}
async function insertTokenScoreParameters(index, prop, id, tokens, token) {
  let tokenFrequency = 0;
  for (const t of tokens) {
    if (t === token) {
      tokenFrequency++;
    }
  }
  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id);
  const tf = tokenFrequency / tokens.length;
  index.frequencies[prop][internalId][token] = tf;
  if (!(token in index.tokenOccurrences[prop])) {
    index.tokenOccurrences[prop][token] = 0;
  }
  index.tokenOccurrences[prop][token] = (index.tokenOccurrences[prop][token] ?? 0) + 1;
}
async function removeDocumentScoreParameters(index, prop, id, docsCount) {
  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id);
  index.avgFieldLength[prop] = (index.avgFieldLength[prop] * docsCount - index.fieldLengths[prop][internalId]) / (docsCount - 1);
  index.fieldLengths[prop][internalId] = void 0;
  index.frequencies[prop][internalId] = void 0;
}
async function removeTokenScoreParameters(index, prop, token) {
  index.tokenOccurrences[prop][token]--;
}
async function calculateResultScores(context, index, prop, term, ids) {
  const documentIDs = Array.from(ids);
  const avgFieldLength = index.avgFieldLength[prop];
  const fieldLengths = index.fieldLengths[prop];
  const oramaOccurrences = index.tokenOccurrences[prop];
  const oramaFrequencies = index.frequencies[prop];
  const termOccurrences = typeof oramaOccurrences[term] === "number" ? oramaOccurrences[term] ?? 0 : 0;
  const scoreList = [];
  const documentIDsLength = documentIDs.length;
  for (let k2 = 0; k2 < documentIDsLength; k2++) {
    var _oramaFrequencies_internalId;
    const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, documentIDs[k2]);
    const tf = (oramaFrequencies === null || oramaFrequencies === void 0 ? void 0 : (_oramaFrequencies_internalId = oramaFrequencies[internalId]) === null || _oramaFrequencies_internalId === void 0 ? void 0 : _oramaFrequencies_internalId[term]) ?? 0;
    const bm25 = BM25(tf, termOccurrences, context.docsCount, fieldLengths[internalId], avgFieldLength, context.params.relevance);
    scoreList.push([
      internalId,
      bm25
    ]);
  }
  return scoreList;
}
async function create4(orama, sharedInternalDocumentStore, schema, index, prefix = "") {
  if (!index) {
    index = {
      sharedInternalDocumentStore,
      indexes: {},
      searchableProperties: [],
      searchablePropertiesWithTypes: {},
      frequencies: {},
      tokenOccurrences: {},
      avgFieldLength: {},
      fieldLengths: {}
    };
  }
  for (const [prop, type] of Object.entries(schema)) {
    const typeActualType = typeof type;
    const path = `${prefix}${prefix ? "." : ""}${prop}`;
    if (typeActualType === "object" && !Array.isArray(type)) {
      create4(orama, sharedInternalDocumentStore, type, index, path);
      continue;
    }
    switch (type) {
      case "boolean":
      case "boolean[]":
        index.indexes[path] = {
          true: [],
          false: []
        };
        break;
      case "number":
      case "number[]":
        index.indexes[path] = create2(0, []);
        break;
      case "string":
      case "string[]":
        index.indexes[path] = create3();
        index.avgFieldLength[path] = 0;
        index.frequencies[path] = {};
        index.tokenOccurrences[path] = {};
        index.fieldLengths[path] = {};
        break;
      default:
        throw createError("INVALID_SCHEMA_TYPE", Array.isArray(type) ? "array" : type, path);
    }
    index.searchableProperties.push(path);
    index.searchablePropertiesWithTypes[path] = type;
  }
  return index;
}
async function insertScalar(implementation, index, prop, id, value, schemaType, language, tokenizer, docsCount) {
  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id);
  switch (schemaType) {
    case "boolean": {
      const booleanIndex = index.indexes[prop];
      booleanIndex[value ? "true" : "false"].push(internalId);
      break;
    }
    case "number":
      insert(index.indexes[prop], value, [
        internalId
      ]);
      break;
    case "string": {
      const tokens = await tokenizer.tokenize(value, language, prop);
      await implementation.insertDocumentScoreParameters(index, prop, internalId, tokens, docsCount);
      for (const token of tokens) {
        await implementation.insertTokenScoreParameters(index, prop, internalId, tokens, token);
        insert2(index.indexes[prop], token, internalId);
      }
      break;
    }
  }
}
async function insert3(implementation, index, prop, id, value, schemaType, language, tokenizer, docsCount) {
  if (!isArrayType(schemaType)) {
    return insertScalar(implementation, index, prop, id, value, schemaType, language, tokenizer, docsCount);
  }
  const innerSchemaType = getInnerType(schemaType);
  const elements = value;
  const elementsLength = elements.length;
  for (let i = 0; i < elementsLength; i++) {
    await insertScalar(implementation, index, prop, id, elements[i], innerSchemaType, language, tokenizer, docsCount);
  }
}
async function removeScalar(implementation, index, prop, id, value, schemaType, language, tokenizer, docsCount) {
  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id);
  switch (schemaType) {
    case "number": {
      removeDocument(index.indexes[prop], internalId, value);
      return true;
    }
    case "boolean": {
      const booleanKey = value ? "true" : "false";
      const position = index.indexes[prop][booleanKey].indexOf(internalId);
      index.indexes[prop][value ? "true" : "false"].splice(position, 1);
      return true;
    }
    case "string": {
      const tokens = await tokenizer.tokenize(value, language, prop);
      await implementation.removeDocumentScoreParameters(index, prop, id, docsCount);
      for (const token of tokens) {
        await implementation.removeTokenScoreParameters(index, prop, token);
        removeDocumentByWord(index.indexes[prop], token, internalId);
      }
      return true;
    }
  }
}
async function remove3(implementation, index, prop, id, value, schemaType, language, tokenizer, docsCount) {
  if (!isArrayType(schemaType)) {
    return removeScalar(implementation, index, prop, id, value, schemaType, language, tokenizer, docsCount);
  }
  const innerSchemaType = getInnerType(schemaType);
  const elements = value;
  const elementsLength = elements.length;
  for (let i = 0; i < elementsLength; i++) {
    await removeScalar(implementation, index, prop, id, elements[i], innerSchemaType, language, tokenizer, docsCount);
  }
  return true;
}
async function search(context, index, prop, term) {
  if (!(prop in index.tokenOccurrences)) {
    return [];
  }
  const rootNode = index.indexes[prop];
  const { exact, tolerance } = context.params;
  const searchResult = find2(rootNode, {
    term,
    exact,
    tolerance
  });
  const ids = /* @__PURE__ */ new Set();
  for (const key in searchResult) {
    for (const id of searchResult[key]) {
      ids.add(id);
    }
  }
  return context.index.calculateResultScores(context, index, prop, term, Array.from(ids));
}
async function searchByWhereClause(context, index, filters) {
  const filterKeys = Object.keys(filters);
  const filtersMap = filterKeys.reduce((acc, key) => ({
    [key]: [],
    ...acc
  }), {});
  for (const param of filterKeys) {
    const operation = filters[param];
    if (typeof operation === "boolean") {
      const idx = index.indexes[param];
      if (typeof idx === "undefined") {
        throw createError("UNKNOWN_FILTER_PROPERTY", param);
      }
      const filteredIDs = idx[operation.toString()];
      filtersMap[param].push(...filteredIDs);
      continue;
    }
    if (typeof operation === "string" || Array.isArray(operation)) {
      const idx = index.indexes[param];
      if (typeof idx === "undefined") {
        throw createError("UNKNOWN_FILTER_PROPERTY", param);
      }
      for (const raw of [
        operation
      ].flat()) {
        const term = await context.tokenizer.tokenize(raw, context.language, param);
        const filteredIDsResults = find2(idx, {
          term: term[0],
          exact: true
        });
        filtersMap[param].push(...Object.values(filteredIDsResults).flat());
      }
      continue;
    }
    const operationKeys = Object.keys(operation);
    if (operationKeys.length > 1) {
      throw createError("INVALID_FILTER_OPERATION", operationKeys.length);
    }
    const operationOpt = operationKeys[0];
    const operationValue = operation[operationOpt];
    const AVLNode = index.indexes[param];
    if (typeof AVLNode === "undefined") {
      throw createError("UNKNOWN_FILTER_PROPERTY", param);
    }
    switch (operationOpt) {
      case "gt": {
        const filteredIDs = greaterThan(AVLNode, operationValue, false);
        filtersMap[param].push(...filteredIDs);
        break;
      }
      case "gte": {
        const filteredIDs = greaterThan(AVLNode, operationValue, true);
        filtersMap[param].push(...filteredIDs);
        break;
      }
      case "lt": {
        const filteredIDs = lessThan(AVLNode, operationValue, false);
        filtersMap[param].push(...filteredIDs);
        break;
      }
      case "lte": {
        const filteredIDs = lessThan(AVLNode, operationValue, true);
        filtersMap[param].push(...filteredIDs);
        break;
      }
      case "eq": {
        const filteredIDs = find(AVLNode, operationValue) ?? [];
        filtersMap[param].push(...filteredIDs);
        break;
      }
      case "between": {
        const [min, max] = operationValue;
        const filteredIDs = rangeSearch(AVLNode, min, max);
        filtersMap[param].push(...filteredIDs);
      }
    }
  }
  const result = intersect(Object.values(filtersMap));
  return result;
}
async function getSearchableProperties(index) {
  return index.searchableProperties;
}
async function getSearchablePropertiesWithTypes(index) {
  return index.searchablePropertiesWithTypes;
}
function loadNode(node) {
  const convertedNode = create3(node.end, node.subWord, node.key);
  convertedNode.docs = node.docs;
  convertedNode.word = node.word;
  for (const childrenKey of Object.keys(node.children)) {
    convertedNode.children[childrenKey] = loadNode(node.children[childrenKey]);
  }
  return convertedNode;
}
async function load3(sharedInternalDocumentStore, raw) {
  const { indexes: rawIndexes, searchableProperties, searchablePropertiesWithTypes, frequencies, tokenOccurrences, avgFieldLength, fieldLengths } = raw;
  const indexes = {};
  for (const prop of Object.keys(rawIndexes)) {
    const value = rawIndexes[prop];
    if (!("word" in value)) {
      indexes[prop] = value;
      continue;
    }
    indexes[prop] = loadNode(value);
  }
  return {
    sharedInternalDocumentStore,
    indexes,
    searchableProperties,
    searchablePropertiesWithTypes,
    frequencies,
    tokenOccurrences,
    avgFieldLength,
    fieldLengths
  };
}
async function save3(index) {
  const { indexes, searchableProperties, searchablePropertiesWithTypes, frequencies, tokenOccurrences, avgFieldLength, fieldLengths } = index;
  return {
    indexes,
    searchableProperties,
    searchablePropertiesWithTypes,
    frequencies,
    tokenOccurrences,
    avgFieldLength,
    fieldLengths
  };
}
async function createIndex() {
  return {
    create: create4,
    insert: insert3,
    remove: remove3,
    insertDocumentScoreParameters,
    insertTokenScoreParameters,
    removeDocumentScoreParameters,
    removeTokenScoreParameters,
    calculateResultScores,
    search,
    searchByWhereClause,
    getSearchableProperties,
    getSearchablePropertiesWithTypes,
    load: load3,
    save: save3
  };
}

// node_modules/@orama/orama/dist/components/tokenizer/index.js
var tokenizer_exports = {};
__export(tokenizer_exports, {
  createTokenizer: () => createTokenizer
});

// node_modules/@orama/orama/dist/components/tokenizer/diacritics.js
var DIACRITICS_CHARCODE_START = 192;
var DIACRITICS_CHARCODE_END = 383;
var CHARCODE_REPLACE_MAPPING = [
  65,
  65,
  65,
  65,
  65,
  65,
  65,
  67,
  69,
  69,
  69,
  69,
  73,
  73,
  73,
  73,
  69,
  78,
  79,
  79,
  79,
  79,
  79,
  null,
  79,
  85,
  85,
  85,
  85,
  89,
  80,
  115,
  97,
  97,
  97,
  97,
  97,
  97,
  97,
  99,
  101,
  101,
  101,
  101,
  105,
  105,
  105,
  105,
  101,
  110,
  111,
  111,
  111,
  111,
  111,
  null,
  111,
  117,
  117,
  117,
  117,
  121,
  112,
  121,
  65,
  97,
  65,
  97,
  65,
  97,
  67,
  99,
  67,
  99,
  67,
  99,
  67,
  99,
  68,
  100,
  68,
  100,
  69,
  101,
  69,
  101,
  69,
  101,
  69,
  101,
  69,
  101,
  71,
  103,
  71,
  103,
  71,
  103,
  71,
  103,
  72,
  104,
  72,
  104,
  73,
  105,
  73,
  105,
  73,
  105,
  73,
  105,
  73,
  105,
  73,
  105,
  74,
  106,
  75,
  107,
  107,
  76,
  108,
  76,
  108,
  76,
  108,
  76,
  108,
  76,
  108,
  78,
  110,
  78,
  110,
  78,
  110,
  110,
  78,
  110,
  79,
  111,
  79,
  111,
  79,
  111,
  79,
  111,
  82,
  114,
  82,
  114,
  82,
  114,
  83,
  115,
  83,
  115,
  83,
  115,
  83,
  115,
  84,
  116,
  84,
  116,
  84,
  116,
  85,
  117,
  85,
  117,
  85,
  117,
  85,
  117,
  85,
  117,
  85,
  117,
  87,
  119,
  89,
  121,
  89,
  90,
  122,
  90,
  122,
  90,
  122,
  115
];
function replaceChar(charCode) {
  if (charCode < DIACRITICS_CHARCODE_START || charCode > DIACRITICS_CHARCODE_END)
    return charCode;
  return CHARCODE_REPLACE_MAPPING[charCode - DIACRITICS_CHARCODE_START] || charCode;
}
function replaceDiacritics(str) {
  const stringCharCode = [];
  for (let idx = 0; idx < str.length; idx++) {
    stringCharCode[idx] = replaceChar(str.charCodeAt(idx));
  }
  return String.fromCharCode(...stringCharCode);
}

// node_modules/@orama/orama/dist/components/tokenizer/english-stemmer.js
var step2List = {
  ational: "ate",
  tional: "tion",
  enci: "ence",
  anci: "ance",
  izer: "ize",
  bli: "ble",
  alli: "al",
  entli: "ent",
  eli: "e",
  ousli: "ous",
  ization: "ize",
  ation: "ate",
  ator: "ate",
  alism: "al",
  iveness: "ive",
  fulness: "ful",
  ousness: "ous",
  aliti: "al",
  iviti: "ive",
  biliti: "ble",
  logi: "log"
};
var step3List = {
  icate: "ic",
  ative: "",
  alize: "al",
  iciti: "ic",
  ical: "ic",
  ful: "",
  ness: ""
};
var c = "[^aeiou]";
var v = "[aeiouy]";
var C = c + "[^aeiouy]*";
var V = v + "[aeiou]*";
var mgr0 = "^(" + C + ")?" + V + C;
var meq1 = "^(" + C + ")?" + V + C + "(" + V + ")?$";
var mgr1 = "^(" + C + ")?" + V + C + V + C;
var s_v = "^(" + C + ")?" + v;
function stemmer(w) {
  let stem;
  let suffix;
  let re;
  let re2;
  let re3;
  let re4;
  if (w.length < 3) {
    return w;
  }
  const firstch = w.substring(0, 1);
  if (firstch == "y") {
    w = firstch.toUpperCase() + w.substring(1);
  }
  re = /^(.+?)(ss|i)es$/;
  re2 = /^(.+?)([^s])s$/;
  if (re.test(w)) {
    w = w.replace(re, "$1$2");
  } else if (re2.test(w)) {
    w = w.replace(re2, "$1$2");
  }
  re = /^(.+?)eed$/;
  re2 = /^(.+?)(ed|ing)$/;
  if (re.test(w)) {
    const fp = re.exec(w);
    re = new RegExp(mgr0);
    if (re.test(fp[1])) {
      re = /.$/;
      w = w.replace(re, "");
    }
  } else if (re2.test(w)) {
    const fp = re2.exec(w);
    stem = fp[1];
    re2 = new RegExp(s_v);
    if (re2.test(stem)) {
      w = stem;
      re2 = /(at|bl|iz)$/;
      re3 = new RegExp("([^aeiouylsz])\\1$");
      re4 = new RegExp("^" + C + v + "[^aeiouwxy]$");
      if (re2.test(w)) {
        w = w + "e";
      } else if (re3.test(w)) {
        re = /.$/;
        w = w.replace(re, "");
      } else if (re4.test(w)) {
        w = w + "e";
      }
    }
  }
  re = /^(.+?)y$/;
  if (re.test(w)) {
    const fp = re.exec(w);
    stem = fp === null || fp === void 0 ? void 0 : fp[1];
    re = new RegExp(s_v);
    if (stem && re.test(stem)) {
      w = stem + "i";
    }
  }
  re = /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/;
  if (re.test(w)) {
    const fp = re.exec(w);
    stem = fp === null || fp === void 0 ? void 0 : fp[1];
    suffix = fp === null || fp === void 0 ? void 0 : fp[2];
    re = new RegExp(mgr0);
    if (stem && re.test(stem)) {
      w = stem + step2List[suffix];
    }
  }
  re = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/;
  if (re.test(w)) {
    const fp = re.exec(w);
    stem = fp === null || fp === void 0 ? void 0 : fp[1];
    suffix = fp === null || fp === void 0 ? void 0 : fp[2];
    re = new RegExp(mgr0);
    if (stem && re.test(stem)) {
      w = stem + step3List[suffix];
    }
  }
  re = /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/;
  re2 = /^(.+?)(s|t)(ion)$/;
  if (re.test(w)) {
    const fp = re.exec(w);
    stem = fp === null || fp === void 0 ? void 0 : fp[1];
    re = new RegExp(mgr1);
    if (stem && re.test(stem)) {
      w = stem;
    }
  } else if (re2.test(w)) {
    const fp = re2.exec(w);
    stem = (fp === null || fp === void 0 ? void 0 : fp[1]) ?? "" + (fp === null || fp === void 0 ? void 0 : fp[2]) ?? "";
    re2 = new RegExp(mgr1);
    if (re2.test(stem)) {
      w = stem;
    }
  }
  re = /^(.+?)e$/;
  if (re.test(w)) {
    const fp = re.exec(w);
    stem = fp === null || fp === void 0 ? void 0 : fp[1];
    re = new RegExp(mgr1);
    re2 = new RegExp(meq1);
    re3 = new RegExp("^" + C + v + "[^aeiouwxy]$");
    if (stem && (re.test(stem) || re2.test(stem) && !re3.test(stem))) {
      w = stem;
    }
  }
  re = /ll$/;
  re2 = new RegExp(mgr1);
  if (re.test(w) && re2.test(w)) {
    re = /.$/;
    w = w.replace(re, "");
  }
  if (firstch == "y") {
    w = firstch.toLowerCase() + w.substring(1);
  }
  return w;
}

// node_modules/@orama/orama/dist/components/tokenizer/index.js
function normalizeToken(prop, token) {
  var _this_stopWords;
  const key = `${this.language}:${prop}:${token}`;
  if (this.normalizationCache.has(key)) {
    return this.normalizationCache.get(key);
  }
  if ((_this_stopWords = this.stopWords) === null || _this_stopWords === void 0 ? void 0 : _this_stopWords.includes(token)) {
    this.normalizationCache.set(key, "");
    return "";
  }
  if (this.stemmer && !this.stemmerSkipProperties.has(prop)) {
    token = this.stemmer(token);
  }
  token = replaceDiacritics(token);
  this.normalizationCache.set(key, token);
  return token;
}
function trim(text) {
  while (text[text.length - 1] === "") {
    text.pop();
  }
  while (text[0] === "") {
    text.shift();
  }
  return text;
}
function tokenize(input, language, prop) {
  if (language && language !== this.language) {
    throw createError("LANGUAGE_NOT_SUPPORTED", language);
  }
  if (typeof input !== "string") {
    return [
      input
    ];
  }
  const splitRule = SPLITTERS[this.language];
  const tokens = input.toLowerCase().split(splitRule).map(this.normalizeToken.bind(this, prop ?? "")).filter(Boolean);
  const trimTokens = trim(tokens);
  if (!this.allowDuplicates) {
    return Array.from(new Set(trimTokens));
  }
  return trimTokens;
}
async function createTokenizer(config = {}) {
  if (!config.language) {
    config.language = "english";
  } else if (!SUPPORTED_LANGUAGES.includes(config.language)) {
    throw createError("LANGUAGE_NOT_SUPPORTED", config.language);
  }
  let stemmer2;
  if (config.stemming || config.stemmer && !("stemming" in config)) {
    if (config.stemmer) {
      if (typeof config.stemmer !== "function") {
        throw createError("INVALID_STEMMER_FUNCTION_TYPE");
      }
      stemmer2 = config.stemmer;
    } else {
      if (config.language === "english") {
        stemmer2 = stemmer;
      } else {
        throw createError("MISSING_STEMMER", config.language);
      }
    }
  }
  let stopWords;
  if (config.stopWords !== false) {
    stopWords = [];
    if (Array.isArray(config.stopWords)) {
      stopWords = config.stopWords;
    } else if (typeof config.stopWords === "function") {
      stopWords = await config.stopWords(stopWords);
    } else if (config.stopWords) {
      throw createError("CUSTOM_STOP_WORDS_MUST_BE_FUNCTION_OR_ARRAY");
    }
    if (!Array.isArray(stopWords)) {
      throw createError("CUSTOM_STOP_WORDS_MUST_BE_FUNCTION_OR_ARRAY");
    }
    for (const s of stopWords) {
      if (typeof s !== "string") {
        throw createError("CUSTOM_STOP_WORDS_MUST_BE_FUNCTION_OR_ARRAY");
      }
    }
  }
  const tokenizer = {
    tokenize,
    language: config.language,
    stemmer: stemmer2,
    stemmerSkipProperties: new Set(config.stemmerSkipProperties ? [
      config.stemmerSkipProperties
    ].flat() : []),
    stopWords,
    allowDuplicates: Boolean(config.allowDuplicates),
    normalizeToken,
    normalizationCache: /* @__PURE__ */ new Map()
  };
  tokenizer.tokenize = tokenize.bind(tokenizer);
  tokenizer.normalizeToken = normalizeToken;
  return tokenizer;
}

// node_modules/@orama/orama/dist/components/sorter.js
var sorter_exports = {};
__export(sorter_exports, {
  createSorter: () => createSorter,
  load: () => load4,
  save: () => save4
});
function innerCreate(orama, sharedInternalDocumentStore, schema, sortableDeniedProperties, prefix) {
  const sorter = {
    language: orama.tokenizer.language,
    sharedInternalDocumentStore,
    enabled: true,
    isSorted: true,
    sortableProperties: [],
    sortablePropertiesWithTypes: {},
    sorts: {}
  };
  for (const [prop, type] of Object.entries(schema)) {
    const typeActualType = typeof type;
    const path = `${prefix}${prefix ? "." : ""}${prop}`;
    if (sortableDeniedProperties.includes(path)) {
      continue;
    }
    if (typeActualType === "object" && !Array.isArray(type)) {
      const ret = innerCreate(orama, sharedInternalDocumentStore, type, sortableDeniedProperties, path);
      sorter.sortableProperties.push(...ret.sortableProperties);
      sorter.sorts = {
        ...sorter.sorts,
        ...ret.sorts
      };
      sorter.sortablePropertiesWithTypes = {
        ...sorter.sortablePropertiesWithTypes,
        ...ret.sortablePropertiesWithTypes
      };
      continue;
    }
    switch (type) {
      case "boolean":
      case "number":
      case "string":
        sorter.sortableProperties.push(path);
        sorter.sortablePropertiesWithTypes[path] = type;
        sorter.sorts[path] = {
          docs: /* @__PURE__ */ new Map(),
          orderedDocsToRemove: /* @__PURE__ */ new Map(),
          orderedDocs: [],
          type
        };
        break;
      case "boolean[]":
      case "number[]":
      case "string[]":
        continue;
      default:
        throw createError("INVALID_SORT_SCHEMA_TYPE", Array.isArray(type) ? "array" : type, path);
    }
  }
  return sorter;
}
async function create5(orama, sharedInternalDocumentStore, schema, config) {
  const isSortEnabled = (config === null || config === void 0 ? void 0 : config.enabled) !== false;
  if (!isSortEnabled) {
    return {
      disabled: true
    };
  }
  return innerCreate(orama, sharedInternalDocumentStore, schema, (config || {}).unsortableProperties || [], "");
}
async function insert4(sorter, prop, id, value) {
  if (!sorter.enabled) {
    return;
  }
  sorter.isSorted = false;
  const internalId = getInternalDocumentId(sorter.sharedInternalDocumentStore, id);
  const s = sorter.sorts[prop];
  s.docs.set(internalId, s.orderedDocs.length);
  s.orderedDocs.push([
    internalId,
    value
  ]);
}
function ensureIsSorted(sorter) {
  if (sorter.isSorted) {
    return;
  }
  if (!sorter.enabled) {
    return;
  }
  const properties = Object.keys(sorter.sorts);
  for (const prop of properties) {
    ensurePropertyIsSorted(sorter, prop);
  }
  sorter.isSorted = true;
}
function stringSort(language, value, d) {
  return value[1].localeCompare(d[1], language);
}
function numberSort(value, d) {
  return value[1] - d[1];
}
function booleanSort(value, d) {
  return d[1] ? -1 : 1;
}
function ensurePropertyIsSorted(sorter, prop) {
  const s = sorter.sorts[prop];
  let predicate;
  switch (s.type) {
    case "string":
      predicate = stringSort.bind(null, sorter.language);
      break;
    case "number":
      predicate = numberSort.bind(null);
      break;
    case "boolean":
      predicate = booleanSort.bind(null);
      break;
  }
  s.orderedDocs.sort(predicate);
  const orderedDocsLength = s.orderedDocs.length;
  for (let i = 0; i < orderedDocsLength; i++) {
    const docId = s.orderedDocs[i][0];
    s.docs.set(docId, i);
  }
}
function ensureOrderedDocsAreDeleted(sorter) {
  const properties = Object.keys(sorter.sorts);
  for (const prop of properties) {
    ensureOrderedDocsAreDeletedByProperty(sorter, prop);
  }
}
function ensureOrderedDocsAreDeletedByProperty(sorter, prop) {
  const s = sorter.sorts[prop];
  if (!s.orderedDocsToRemove.size)
    return;
  s.orderedDocs = s.orderedDocs.filter((doc) => !s.orderedDocsToRemove.has(doc[0]));
  s.orderedDocsToRemove.clear();
}
async function remove4(sorter, prop, id) {
  if (!sorter.enabled) {
    return;
  }
  const s = sorter.sorts[prop];
  const internalId = getInternalDocumentId(sorter.sharedInternalDocumentStore, id);
  const index = s.docs.get(internalId);
  if (!index)
    return;
  s.docs.delete(internalId);
  s.orderedDocsToRemove.set(internalId, true);
}
async function sortBy(sorter, docIds, by) {
  if (!sorter.enabled) {
    throw createError("SORT_DISABLED");
  }
  const property = by.property;
  const isDesc = by.order === "DESC";
  const s = sorter.sorts[property];
  if (!s) {
    throw createError("UNABLE_TO_SORT_ON_UNKNOWN_FIELD", property, sorter.sortableProperties.join(", "));
  }
  ensureOrderedDocsAreDeletedByProperty(sorter, property);
  ensureIsSorted(sorter);
  docIds.sort((a, b) => {
    const indexOfA = s.docs.get(getInternalDocumentId(sorter.sharedInternalDocumentStore, a[0]));
    const indexOfB = s.docs.get(getInternalDocumentId(sorter.sharedInternalDocumentStore, b[0]));
    const isAIndexed = typeof indexOfA !== "undefined";
    const isBIndexed = typeof indexOfB !== "undefined";
    if (!isAIndexed && !isBIndexed) {
      return 0;
    }
    if (!isAIndexed) {
      return 1;
    }
    if (!isBIndexed) {
      return -1;
    }
    return isDesc ? indexOfB - indexOfA : indexOfA - indexOfB;
  });
  return docIds;
}
async function getSortableProperties(sorter) {
  if (!sorter.enabled) {
    return [];
  }
  return sorter.sortableProperties;
}
async function getSortablePropertiesWithTypes(sorter) {
  if (!sorter.enabled) {
    return {};
  }
  return sorter.sortablePropertiesWithTypes;
}
async function load4(sharedInternalDocumentStore, raw) {
  const rawDocument = raw;
  if (!rawDocument.enabled) {
    return {
      enabled: false
    };
  }
  const sorts = Object.keys(rawDocument.sorts).reduce((acc, prop) => {
    const { docs, orderedDocs, type } = rawDocument.sorts[prop];
    acc[prop] = {
      docs: new Map(Object.entries(docs).map(([k2, v2]) => [
        +k2,
        v2
      ])),
      orderedDocsToRemove: /* @__PURE__ */ new Map(),
      orderedDocs,
      type
    };
    return acc;
  }, {});
  return {
    sharedInternalDocumentStore,
    language: rawDocument.language,
    sortableProperties: rawDocument.sortableProperties,
    sortablePropertiesWithTypes: rawDocument.sortablePropertiesWithTypes,
    sorts,
    enabled: true,
    isSorted: rawDocument.isSorted
  };
}
async function save4(sorter) {
  if (!sorter.enabled) {
    return {
      enabled: false
    };
  }
  ensureOrderedDocsAreDeleted(sorter);
  ensureIsSorted(sorter);
  const sorts = Object.keys(sorter.sorts).reduce((acc, prop) => {
    const { docs, orderedDocs, type } = sorter.sorts[prop];
    acc[prop] = {
      docs: Object.fromEntries(docs.entries()),
      orderedDocs,
      type
    };
    return acc;
  }, {});
  return {
    language: sorter.language,
    sortableProperties: sorter.sortableProperties,
    sortablePropertiesWithTypes: sorter.sortablePropertiesWithTypes,
    sorts,
    enabled: sorter.enabled,
    isSorted: sorter.isSorted
  };
}
async function createSorter() {
  return {
    create: create5,
    insert: insert4,
    remove: remove4,
    save: save4,
    load: load4,
    sortBy,
    getSortableProperties,
    getSortablePropertiesWithTypes
  };
}

// node_modules/@orama/orama/dist/methods/create.js
function validateComponents(components) {
  const defaultComponents = {
    formatElapsedTime,
    getDocumentIndexId,
    getDocumentProperties,
    validateSchema
  };
  for (const rawKey of FUNCTION_COMPONENTS) {
    const key = rawKey;
    if (components[key]) {
      if (typeof components[key] !== "function") {
        throw createError("COMPONENT_MUST_BE_FUNCTION", key);
      }
    } else {
      components[key] = defaultComponents[key];
    }
  }
  for (const rawKey of SINGLE_OR_ARRAY_COMPONENTS) {
    const key = rawKey;
    const component = components[key];
    if (!component) {
      components[key] = [];
    } else if (!Array.isArray(components[key])) {
      components[key] = [
        components[key]
      ];
    }
    for (const fn of components[key]) {
      if (typeof fn !== "function") {
        throw createError("COMPONENT_MUST_BE_FUNCTION_OR_ARRAY_FUNCTIONS", key);
      }
    }
  }
  for (const rawKey of Object.keys(components)) {
    if (!OBJECT_COMPONENTS.includes(rawKey) && !FUNCTION_COMPONENTS.includes(rawKey) && !SINGLE_OR_ARRAY_COMPONENTS.includes(rawKey)) {
      throw createError("UNSUPPORTED_COMPONENT", rawKey);
    }
  }
}
async function create6({ schema, sort, language, components, id }) {
  if (!components) {
    components = {};
  }
  if (!id) {
    id = await uniqueId();
  }
  let tokenizer = components.tokenizer;
  let index = components.index;
  let documentsStore = components.documentsStore;
  let sorter = components.sorter;
  if (!tokenizer) {
    tokenizer = await createTokenizer({
      language: language ?? "english"
    });
  } else if (!tokenizer.tokenize) {
    tokenizer = await createTokenizer(tokenizer);
  }
  if (components.tokenizer && language) {
    throw createError("NO_LANGUAGE_WITH_CUSTOM_TOKENIZER");
  }
  const internalDocumentStore = createInternalDocumentIDStore();
  index || (index = await createIndex());
  sorter || (sorter = await createSorter());
  documentsStore || (documentsStore = await createDocumentsStore());
  validateComponents(components);
  const { getDocumentProperties: getDocumentProperties2, getDocumentIndexId: getDocumentIndexId2, validateSchema: validateSchema2, beforeInsert, afterInsert, beforeRemove, afterRemove, beforeUpdate, afterUpdate, afterSearch, beforeMultipleInsert, afterMultipleInsert, beforeMultipleRemove, afterMultipleRemove, beforeMultipleUpdate, afterMultipleUpdate, formatElapsedTime: formatElapsedTime2 } = components;
  const orama = {
    data: {},
    caches: {},
    schema,
    tokenizer,
    index,
    sorter,
    documentsStore,
    internalDocumentIDStore: internalDocumentStore,
    getDocumentProperties: getDocumentProperties2,
    getDocumentIndexId: getDocumentIndexId2,
    validateSchema: validateSchema2,
    beforeInsert,
    afterInsert,
    beforeRemove,
    afterRemove,
    beforeUpdate,
    afterUpdate,
    afterSearch,
    beforeMultipleInsert,
    afterMultipleInsert,
    beforeMultipleRemove,
    afterMultipleRemove,
    beforeMultipleUpdate,
    afterMultipleUpdate,
    formatElapsedTime: formatElapsedTime2,
    id
  };
  orama.data = {
    index: await orama.index.create(orama, internalDocumentStore, schema),
    docs: await orama.documentsStore.create(orama, internalDocumentStore),
    sorting: await orama.sorter.create(orama, internalDocumentStore, schema, sort)
  };
  return orama;
}

// node_modules/@orama/orama/dist/methods/docs.js
function getByID(db, id) {
  return db.documentsStore.get(db.data.docs, id);
}
function count2(db) {
  return db.documentsStore.count(db.data.docs);
}

// node_modules/@orama/orama/dist/components.js
var components_exports2 = {};
__export(components_exports2, {
  documentsStore: () => documents_store_exports,
  formatElapsedTime: () => formatElapsedTime,
  getDocumentIndexId: () => getDocumentIndexId,
  getDocumentProperties: () => getDocumentProperties,
  getInnerType: () => getInnerType,
  index: () => components_exports,
  internalDocumentIDStore: () => internal_document_id_store_exports,
  isArrayType: () => isArrayType,
  sorter: () => sorter_exports,
  tokenizer: () => tokenizer_exports,
  validateSchema: () => validateSchema
});

// node_modules/@orama/orama/dist/types.js
var kInsertions = Symbol("orama.insertions");
var kRemovals = Symbol("orama.removals");

// node_modules/@orama/orama/dist/components/sync-blocking-checker.js
var _globalThis_process;
var warn = ((_globalThis_process = globalThis.process) === null || _globalThis_process === void 0 ? void 0 : _globalThis_process.emitWarning) ?? function emitWarning(message, options) {
  console.warn(`[WARNING] [${options.code}] ${message}`);
};
function trackInsertion(orama) {
  if (typeof orama[kInsertions] !== "number") {
    queueMicrotask(() => {
      orama[kInsertions] = void 0;
    });
    orama[kInsertions] = 0;
  }
  if (orama[kInsertions] > 1e3) {
    warn("Orama's insert operation is synchronous. Please avoid inserting a large number of document in a single operation in order not to block the main thread or, in alternative, please use insertMultiple.", {
      code: "ORAMA0001"
    });
    orama[kInsertions] = -1;
  } else if (orama[kInsertions] >= 0) {
    orama[kInsertions]++;
  }
}
function trackRemoval(orama) {
  if (typeof orama[kRemovals] !== "number") {
    queueMicrotask(() => {
      orama[kRemovals] = void 0;
    });
    orama[kRemovals] = 0;
  }
  if (orama[kRemovals] > 1e3) {
    warn("Orama's remove operation is synchronous. Please avoid removing a large number of document in a single operation in order not to block the main thread, in alternative, please use updateMultiple.", {
      code: "ORAMA0002"
    });
    orama[kRemovals] = -1;
  } else if (orama[kRemovals] >= 0) {
    orama[kRemovals]++;
  }
}

// node_modules/@orama/orama/dist/methods/insert.js
async function insert5(orama, doc, language, skipHooks) {
  const errorProperty = await orama.validateSchema(doc, orama.schema);
  if (errorProperty) {
    throw createError("SCHEMA_VALIDATION_FAILURE", errorProperty);
  }
  return innerInsert(orama, doc, language, skipHooks);
}
async function innerInsert(orama, doc, language, skipHooks) {
  const { index, docs } = orama.data;
  const id = await orama.getDocumentIndexId(doc);
  if (typeof id !== "string") {
    throw createError("DOCUMENT_ID_MUST_BE_STRING", typeof id);
  }
  if (!await orama.documentsStore.store(docs, id, doc)) {
    throw createError("DOCUMENT_ALREADY_EXISTS", id);
  }
  const docsCount = await orama.documentsStore.count(docs);
  if (!skipHooks) {
    await runSingleHook(orama.beforeInsert, orama, id, doc);
  }
  const indexableProperties = await orama.index.getSearchableProperties(index);
  const indexablePropertiesWithTypes = await orama.index.getSearchablePropertiesWithTypes(index);
  const indexableValues = await orama.getDocumentProperties(doc, indexableProperties);
  for (const [key, value] of Object.entries(indexableValues)) {
    if (typeof value === "undefined") {
      continue;
    }
    const actualType = typeof value;
    const expectedType = indexablePropertiesWithTypes[key];
    if (isArrayType(expectedType) && Array.isArray(value)) {
      continue;
    }
    if (actualType !== expectedType) {
      throw createError("INVALID_DOCUMENT_PROPERTY", key, expectedType, actualType);
    }
  }
  for (const prop of indexableProperties) {
    var _orama_index, _orama_index_beforeInsert, _orama_index1, _orama_index_afterInsert;
    const value = indexableValues[prop];
    if (typeof value === "undefined") {
      continue;
    }
    const expectedType = indexablePropertiesWithTypes[prop];
    await ((_orama_index_beforeInsert = (_orama_index = orama.index).beforeInsert) === null || _orama_index_beforeInsert === void 0 ? void 0 : _orama_index_beforeInsert.call(_orama_index, orama.data.index, prop, id, value, expectedType, language, orama.tokenizer, docsCount));
    await orama.index.insert(orama.index, orama.data.index, prop, id, value, expectedType, language, orama.tokenizer, docsCount);
    await ((_orama_index_afterInsert = (_orama_index1 = orama.index).afterInsert) === null || _orama_index_afterInsert === void 0 ? void 0 : _orama_index_afterInsert.call(_orama_index1, orama.data.index, prop, id, value, expectedType, language, orama.tokenizer, docsCount));
  }
  const sortableProperties = await orama.sorter.getSortableProperties(orama.data.sorting);
  const sortablePropertiesWithTypes = await orama.sorter.getSortablePropertiesWithTypes(orama.data.sorting);
  const sortableValues = await orama.getDocumentProperties(doc, sortableProperties);
  for (const prop of sortableProperties) {
    const value = sortableValues[prop];
    if (typeof value === "undefined") {
      continue;
    }
    const expectedType = sortablePropertiesWithTypes[prop];
    await orama.sorter.insert(orama.data.sorting, prop, id, value, expectedType, language);
  }
  if (!skipHooks) {
    await runSingleHook(orama.afterInsert, orama, id, doc);
  }
  trackInsertion(orama);
  return id;
}
async function insertMultiple(orama, docs, batchSize, language, skipHooks) {
  if (!skipHooks) {
    await runMultipleHook(orama.beforeMultipleInsert, orama, docs);
  }
  const docsLength = docs.length;
  for (let i = 0; i < docsLength; i++) {
    const errorProperty = await orama.validateSchema(docs[i], orama.schema);
    if (errorProperty) {
      throw createError("SCHEMA_VALIDATION_FAILURE", errorProperty);
    }
  }
  return innerInsertMultiple(orama, docs, batchSize, language, skipHooks);
}
async function innerInsertMultiple(orama, docs, batchSize, language, skipHooks) {
  if (!batchSize) {
    batchSize = 1e3;
  }
  const ids = [];
  await new Promise((resolve, reject) => {
    let i = 0;
    async function _insertMultiple() {
      const batch = docs.slice(i * batchSize, (i + 1) * batchSize);
      i++;
      if (!batch.length) {
        return resolve();
      }
      for (const doc of batch) {
        try {
          const id = await insert5(orama, doc, language, skipHooks);
          ids.push(id);
        } catch (err) {
          reject(err);
        }
      }
      setTimeout(_insertMultiple, 0);
    }
    setTimeout(_insertMultiple, 0);
  });
  if (!skipHooks) {
    await runMultipleHook(orama.afterMultipleInsert, orama, docs);
  }
  return ids;
}

// node_modules/@orama/orama/dist/methods/remove.js
async function remove5(orama, id, language, skipHooks) {
  let result = true;
  const { index, docs } = orama.data;
  const doc = await orama.documentsStore.get(docs, id);
  if (!doc) {
    return false;
  }
  const docId = getDocumentIdFromInternalId(orama.internalDocumentIDStore, getInternalDocumentId(orama.internalDocumentIDStore, id));
  const docsCount = await orama.documentsStore.count(docs);
  if (!skipHooks) {
    await runSingleHook(orama.beforeRemove, orama, docId);
  }
  const indexableProperties = await orama.index.getSearchableProperties(index);
  const indexablePropertiesWithTypes = await orama.index.getSearchablePropertiesWithTypes(index);
  const values = await orama.getDocumentProperties(doc, indexableProperties);
  for (const prop of indexableProperties) {
    var _orama_index, _orama_index_beforeRemove, _orama_index1, _orama_index_afterRemove;
    const value = values[prop];
    if (typeof value === "undefined") {
      continue;
    }
    const schemaType = indexablePropertiesWithTypes[prop];
    await ((_orama_index_beforeRemove = (_orama_index = orama.index).beforeRemove) === null || _orama_index_beforeRemove === void 0 ? void 0 : _orama_index_beforeRemove.call(_orama_index, orama.data.index, prop, docId, value, schemaType, language, orama.tokenizer, docsCount));
    if (!await orama.index.remove(orama.index, orama.data.index, prop, id, value, schemaType, language, orama.tokenizer, docsCount)) {
      result = false;
    }
    await ((_orama_index_afterRemove = (_orama_index1 = orama.index).afterRemove) === null || _orama_index_afterRemove === void 0 ? void 0 : _orama_index_afterRemove.call(_orama_index1, orama.data.index, prop, docId, value, schemaType, language, orama.tokenizer, docsCount));
  }
  const sortableProperties = await orama.sorter.getSortableProperties(orama.data.sorting);
  const sortableValues = await orama.getDocumentProperties(doc, sortableProperties);
  for (const prop of sortableProperties) {
    if (typeof sortableValues[prop] === "undefined") {
      continue;
    }
    await orama.sorter.remove(orama.data.sorting, prop, id);
  }
  if (!skipHooks) {
    await runSingleHook(orama.afterRemove, orama, docId);
  }
  await orama.documentsStore.remove(orama.data.docs, id);
  trackRemoval(orama);
  return result;
}
async function removeMultiple(orama, ids, batchSize, language, skipHooks) {
  let result = 0;
  if (!batchSize) {
    batchSize = 1e3;
  }
  const docIdsForHooks = skipHooks ? [] : ids.map((id) => getDocumentIdFromInternalId(orama.internalDocumentIDStore, getInternalDocumentId(orama.internalDocumentIDStore, id)));
  if (!skipHooks) {
    await runMultipleHook(orama.beforeMultipleRemove, orama, docIdsForHooks);
  }
  await new Promise((resolve, reject) => {
    let i = 0;
    async function _insertMultiple() {
      const batch = ids.slice(i * batchSize, (i + 1) * batchSize);
      i++;
      if (!batch.length) {
        return resolve();
      }
      for (const doc of batch) {
        try {
          if (await remove5(orama, doc, language, skipHooks)) {
            result++;
          }
        } catch (err) {
          reject(err);
        }
      }
      setTimeout(_insertMultiple, 0);
    }
    setTimeout(_insertMultiple, 0);
  });
  if (!skipHooks) {
    await runMultipleHook(orama.afterMultipleRemove, orama, docIdsForHooks);
  }
  return result;
}

// node_modules/@orama/orama/dist/components/facets.js
function sortingPredicate(order = "desc", a, b) {
  if (order.toLowerCase() === "asc") {
    return a[1] - b[1];
  } else {
    return b[1] - a[1];
  }
}
async function getFacets(orama, results, facetsConfig) {
  const facets = {};
  const allIDs = results.map(([id]) => id);
  const allDocs = await orama.documentsStore.getMultiple(orama.data.docs, allIDs);
  const facetKeys = Object.keys(facetsConfig);
  const properties = await orama.index.getSearchablePropertiesWithTypes(orama.data.index);
  for (const facet of facetKeys) {
    let values = {};
    if (properties[facet] === "number") {
      const { ranges } = facetsConfig[facet];
      const tmp = [];
      for (const range of ranges) {
        tmp.push([
          `${range.from}-${range.to}`,
          0
        ]);
      }
      values = Object.fromEntries(tmp);
    }
    facets[facet] = {
      count: 0,
      values
    };
  }
  const allDocsLength = allDocs.length;
  for (let i = 0; i < allDocsLength; i++) {
    const doc = allDocs[i];
    for (const facet of facetKeys) {
      const facetValue = facet.includes(".") ? await getNested(doc, facet) : doc[facet];
      const propertyType = properties[facet];
      switch (propertyType) {
        case "number": {
          const ranges = facetsConfig[facet].ranges;
          calculateNumberFacet(ranges, facets[facet].values, facetValue);
          break;
        }
        case "number[]": {
          const alreadyInsertedValues = /* @__PURE__ */ new Set();
          const ranges = facetsConfig[facet].ranges;
          for (const v2 of facetValue) {
            calculateNumberFacet(ranges, facets[facet].values, v2, alreadyInsertedValues);
          }
          break;
        }
        case "boolean":
        case "string": {
          calculateBooleanOrStringFacet(facets[facet].values, facetValue, propertyType);
          break;
        }
        case "boolean[]":
        case "string[]": {
          const alreadyInsertedValues = /* @__PURE__ */ new Set();
          const innerType = propertyType === "boolean[]" ? "boolean" : "string";
          for (const v2 of facetValue) {
            calculateBooleanOrStringFacet(facets[facet].values, v2, innerType, alreadyInsertedValues);
          }
          break;
        }
      }
    }
  }
  for (const facet of facetKeys) {
    facets[facet].count = Object.keys(facets[facet].values).length;
    if (properties[facet] === "string") {
      const stringFacetDefinition = facetsConfig;
      facets[facet].values = Object.fromEntries(Object.entries(facets[facet].values).sort((a, b) => sortingPredicate(stringFacetDefinition.sort, a, b)).slice(stringFacetDefinition.offset ?? 0, stringFacetDefinition.limit ?? 10));
    }
  }
  return facets;
}
function calculateNumberFacet(ranges, values, facetValue, alreadyInsertedValues) {
  for (const range of ranges) {
    const value = `${range.from}-${range.to}`;
    if (alreadyInsertedValues && alreadyInsertedValues.has(value)) {
      continue;
    }
    if (facetValue >= range.from && facetValue <= range.to) {
      if (values[value] === void 0) {
        values[value] = 1;
      } else {
        values[value]++;
        if (alreadyInsertedValues) {
          alreadyInsertedValues.add(value);
        }
      }
    }
  }
}
function calculateBooleanOrStringFacet(values, facetValue, propertyType, alreadyInsertedValues) {
  const value = (facetValue === null || facetValue === void 0 ? void 0 : facetValue.toString()) ?? (propertyType === "boolean" ? "false" : "");
  if (alreadyInsertedValues && alreadyInsertedValues.has(value)) {
    return;
  }
  values[value] = (values[value] ?? 0) + 1;
  if (alreadyInsertedValues) {
    alreadyInsertedValues.add(value);
  }
}

// node_modules/@orama/orama/dist/components/filters.js
function intersectFilteredIDs(filtered, lookedUp) {
  const map = /* @__PURE__ */ new Map();
  const result = [];
  for (const id of filtered) {
    map.set(id, true);
  }
  for (const [id, score] of lookedUp) {
    if (map.has(id)) {
      result.push([
        id,
        score
      ]);
      map.delete(id);
    }
  }
  return result;
}

// node_modules/@orama/orama/dist/components/groups.js
var DEFAULT_REDUCE = {
  reducer: (_, acc, res, index) => {
    acc[index] = res;
    return acc;
  },
  getInitialValue: (length) => Array.from({
    length
  })
};
var ALLOWED_TYPES = [
  "string",
  "number",
  "boolean"
];
async function getGroups(orama, results, groupBy) {
  const properties = groupBy.properties;
  const propertiesLength = properties.length;
  const schemaProperties = await orama.index.getSearchablePropertiesWithTypes(orama.data.index);
  for (let i = 0; i < propertiesLength; i++) {
    const property = properties[i];
    if (typeof schemaProperties[property] === "undefined") {
      throw createError("UNKNOWN_GROUP_BY_PROPERTY", property);
    }
    if (!ALLOWED_TYPES.includes(schemaProperties[property])) {
      throw createError("INVALID_GROUP_BY_PROPERTY", property, ALLOWED_TYPES.join(", "), schemaProperties[property]);
    }
  }
  const allIDs = results.map(([id]) => getDocumentIdFromInternalId(orama.internalDocumentIDStore, id));
  const allDocs = await orama.documentsStore.getMultiple(orama.data.docs, allIDs);
  const allDocsLength = allDocs.length;
  const returnedCount = groupBy.maxResult || Number.MAX_SAFE_INTEGER;
  const listOfValues = [];
  const g = {};
  for (let i = 0; i < propertiesLength; i++) {
    const groupByKey = properties[i];
    const group = {
      property: groupByKey,
      perValue: {}
    };
    const values = /* @__PURE__ */ new Set();
    for (let j = 0; j < allDocsLength; j++) {
      const doc = allDocs[j];
      const value = await getNested(doc, groupByKey);
      if (typeof value === "undefined") {
        continue;
      }
      const keyValue = typeof value !== "boolean" ? value : "" + value;
      if (typeof group.perValue[keyValue] === "undefined") {
        group.perValue[keyValue] = {
          indexes: [],
          count: 0
        };
      }
      if (group.perValue[keyValue].count >= returnedCount) {
        continue;
      }
      group.perValue[keyValue].indexes.push(j);
      group.perValue[keyValue].count++;
      values.add(value);
    }
    listOfValues.push(Array.from(values));
    g[groupByKey] = group;
  }
  const combinations = calculateCombination(listOfValues);
  const combinationsLength = combinations.length;
  const groups = [];
  for (let i = 0; i < combinationsLength; i++) {
    const combination = combinations[i];
    const combinationLength = combination.length;
    const group = {
      values: [],
      indexes: []
    };
    const indexes = [];
    for (let j = 0; j < combinationLength; j++) {
      const value = combination[j];
      const property = properties[j];
      indexes.push(g[property].perValue[typeof value !== "boolean" ? value : "" + value].indexes);
      group.values.push(value);
    }
    group.indexes = intersect(indexes).sort((a, b) => a - b);
    if (group.indexes.length === 0) {
      continue;
    }
    groups.push(group);
  }
  const groupsLength = groups.length;
  const res = Array.from({
    length: groupsLength
  });
  for (let i = 0; i < groupsLength; i++) {
    const group = groups[i];
    const reduce = groupBy.reduce || DEFAULT_REDUCE;
    const docs = group.indexes.map((index) => {
      return {
        id: allIDs[index],
        score: results[index][1],
        document: allDocs[index]
      };
    });
    const func = reduce.reducer.bind(null, group.values);
    const initialValue = reduce.getInitialValue(group.indexes.length);
    const aggregationValue = docs.reduce(func, initialValue);
    res[i] = {
      values: group.values,
      result: aggregationValue
    };
  }
  return res;
}
function calculateCombination(arrs, index = 0) {
  if (index + 1 === arrs.length)
    return arrs[index].map((item) => [
      item
    ]);
  const head = arrs[index];
  const c2 = calculateCombination(arrs, index + 1);
  const combinations = [];
  for (const value of head) {
    for (const combination of c2) {
      combinations.push([
        value,
        ...combination
      ]);
    }
  }
  return combinations;
}

// node_modules/@orama/orama/dist/methods/search.js
var defaultBM25Params = {
  k: 1.2,
  b: 0.75,
  d: 0.5
};
async function createSearchContext(tokenizer, index, documentsStore, language, params, properties, tokens, docsCount, timeStart) {
  const indexMap = {};
  const docsIntersection = {};
  for (const prop of properties) {
    const tokensMap = {};
    for (const token of tokens) {
      tokensMap[token] = [];
    }
    indexMap[prop] = tokensMap;
    docsIntersection[prop] = [];
  }
  return {
    timeStart,
    tokenizer,
    index,
    documentsStore,
    language,
    params,
    docsCount,
    uniqueDocsIDs: {},
    indexMap,
    docsIntersection
  };
}
async function search2(orama, params, language) {
  const timeStart = await getNanosecondsTime();
  params.relevance = Object.assign(params.relevance ?? {}, defaultBM25Params);
  const shouldCalculateFacets = params.facets && Object.keys(params.facets).length > 0;
  const { limit = 10, offset = 0, term, properties, threshold = 1, distinctOn } = params;
  const isPreflight = params.preflight === true;
  const { index, docs } = orama.data;
  const tokens = await orama.tokenizer.tokenize(term ?? "", language);
  let propertiesToSearch = orama.caches["propertiesToSearch"];
  if (!propertiesToSearch) {
    const propertiesToSearchWithTypes = await orama.index.getSearchablePropertiesWithTypes(index);
    propertiesToSearch = await orama.index.getSearchableProperties(index);
    propertiesToSearch = propertiesToSearch.filter((prop) => propertiesToSearchWithTypes[prop].startsWith("string"));
    orama.caches["propertiesToSearch"] = propertiesToSearch;
  }
  if (properties && properties !== "*") {
    for (const prop of properties) {
      if (!propertiesToSearch.includes(prop)) {
        throw createError("UNKNOWN_INDEX", prop, propertiesToSearch.join(", "));
      }
    }
    propertiesToSearch = propertiesToSearch.filter((prop) => properties.includes(prop));
  }
  const context = await createSearchContext(orama.tokenizer, orama.index, orama.documentsStore, language, params, propertiesToSearch, tokens, await orama.documentsStore.count(docs), timeStart);
  const hasFilters = Object.keys(params.where ?? {}).length > 0;
  let whereFiltersIDs = [];
  if (hasFilters) {
    whereFiltersIDs = await orama.index.searchByWhereClause(context, index, params.where);
  }
  const tokensLength = tokens.length;
  if (tokensLength) {
    const indexesLength = propertiesToSearch.length;
    for (let i = 0; i < indexesLength; i++) {
      var _params_boost;
      const prop = propertiesToSearch[i];
      const tokensLength2 = tokens.length;
      for (let j = 0; j < tokensLength2; j++) {
        const term2 = tokens[j];
        const scoreList = await orama.index.search(context, index, prop, term2);
        context.indexMap[prop][term2].push(...scoreList);
      }
      const docIds = context.indexMap[prop];
      const vals = Object.values(docIds);
      context.docsIntersection[prop] = prioritizeTokenScores(vals, (params === null || params === void 0 ? void 0 : (_params_boost = params.boost) === null || _params_boost === void 0 ? void 0 : _params_boost[prop]) ?? 1, threshold, tokensLength2);
      const uniqueDocs = context.docsIntersection[prop];
      const uniqueDocsLength = uniqueDocs.length;
      for (let i2 = 0; i2 < uniqueDocsLength; i2++) {
        const [id, score] = uniqueDocs[i2];
        const prevScore = context.uniqueDocsIDs[id];
        if (prevScore) {
          context.uniqueDocsIDs[id] = prevScore + score + 0.5;
        } else {
          context.uniqueDocsIDs[id] = score;
        }
      }
    }
  } else if (tokens.length === 0 && term) {
    context.uniqueDocsIDs = {};
  } else {
    context.uniqueDocsIDs = Object.fromEntries(Object.keys(await orama.documentsStore.getAll(orama.data.docs)).map((k2) => [
      k2,
      0
    ]));
  }
  let uniqueDocsArray = Object.entries(context.uniqueDocsIDs).map(([id, score]) => [
    +id,
    score
  ]);
  if (hasFilters) {
    uniqueDocsArray = intersectFilteredIDs(whereFiltersIDs, uniqueDocsArray);
  }
  if (params.sortBy) {
    if (typeof params.sortBy === "function") {
      const ids = uniqueDocsArray.map(([id]) => id);
      const docs2 = await orama.documentsStore.getMultiple(orama.data.docs, ids);
      const docsWithIdAndScore = docs2.map((d, i) => [
        uniqueDocsArray[i][0],
        uniqueDocsArray[i][1],
        d
      ]);
      docsWithIdAndScore.sort(params.sortBy);
      uniqueDocsArray = docsWithIdAndScore.map(([id, score]) => [
        id,
        score
      ]);
    } else {
      uniqueDocsArray = await orama.sorter.sortBy(orama.data.sorting, uniqueDocsArray, params.sortBy).then((results2) => results2.map(([id, score]) => [
        getInternalDocumentId(orama.internalDocumentIDStore, id),
        score
      ]));
    }
  } else {
    uniqueDocsArray = uniqueDocsArray.sort(sortTokenScorePredicate);
  }
  let results;
  if (!isPreflight && distinctOn) {
    results = await fetchDocumentsWithDistinct(orama, uniqueDocsArray, offset, limit, distinctOn);
  } else if (!isPreflight) {
    results = await fetchDocuments(orama, uniqueDocsArray, offset, limit);
  }
  const searchResult = {
    elapsed: {
      formatted: "",
      raw: 0
    },
    // We keep the hits array empty if it's a preflight request.
    hits: [],
    count: uniqueDocsArray.length
  };
  if (typeof results !== "undefined") {
    searchResult.hits = results.filter(Boolean);
  }
  if (shouldCalculateFacets) {
    const facets = await getFacets(orama, uniqueDocsArray, params.facets);
    searchResult.facets = facets;
  }
  if (params.groupBy) {
    searchResult.groups = await getGroups(orama, uniqueDocsArray, params.groupBy);
  }
  if (orama.afterSearch) {
    await runAfterSearch(orama.afterSearch, orama, params, language, searchResult);
  }
  searchResult.elapsed = await orama.formatElapsedTime(await getNanosecondsTime() - context.timeStart);
  return searchResult;
}
async function fetchDocumentsWithDistinct(orama, uniqueDocsArray, offset, limit, distinctOn) {
  const docs = orama.data.docs;
  const values = /* @__PURE__ */ new Map();
  const results = [];
  const resultIDs = /* @__PURE__ */ new Set();
  const uniqueDocsArrayLength = uniqueDocsArray.length;
  let count3 = 0;
  for (let i = 0; i < uniqueDocsArrayLength; i++) {
    const idAndScore = uniqueDocsArray[i];
    if (typeof idAndScore === "undefined") {
      continue;
    }
    const [id, score] = idAndScore;
    if (resultIDs.has(id)) {
      continue;
    }
    const doc = await orama.documentsStore.get(docs, id);
    const value = await getNested(doc, distinctOn);
    if (typeof value === "undefined" || values.has(value)) {
      continue;
    }
    values.set(value, true);
    count3++;
    if (count3 <= offset) {
      continue;
    }
    results.push({
      id: getDocumentIdFromInternalId(orama.internalDocumentIDStore, id),
      score,
      document: doc
    });
    resultIDs.add(id);
    if (count3 >= offset + limit) {
      break;
    }
  }
  return results;
}
async function fetchDocuments(orama, uniqueDocsArray, offset, limit) {
  const docs = orama.data.docs;
  const results = Array.from({
    length: limit
  });
  const resultIDs = /* @__PURE__ */ new Set();
  for (let i = offset; i < limit + offset; i++) {
    const idAndScore = uniqueDocsArray[i];
    if (typeof idAndScore === "undefined") {
      break;
    }
    const [id, score] = idAndScore;
    if (!resultIDs.has(id)) {
      const fullDoc = await orama.documentsStore.get(docs, id);
      results[i] = {
        id: getDocumentIdFromInternalId(orama.internalDocumentIDStore, id),
        score,
        document: fullDoc
      };
      resultIDs.add(id);
    }
  }
  return results;
}

// node_modules/@orama/orama/dist/methods/serialization.js
async function load5(orama, raw) {
  orama.internalDocumentIDStore.load(orama, raw.internalDocumentIDStore);
  orama.data.index = await orama.index.load(orama.internalDocumentIDStore, raw.index);
  orama.data.docs = await orama.documentsStore.load(orama.internalDocumentIDStore, raw.docs);
  orama.data.sorting = await orama.sorter.load(orama.internalDocumentIDStore, raw.sorting);
}
async function save5(orama) {
  return {
    internalDocumentIDStore: orama.internalDocumentIDStore.save(orama.internalDocumentIDStore),
    index: await orama.index.save(orama.data.index),
    docs: await orama.documentsStore.save(orama.data.docs),
    sorting: await orama.sorter.save(orama.data.sorting)
  };
}

// node_modules/@orama/orama/dist/methods/update.js
async function update(orama, id, doc, language, skipHooks) {
  if (!skipHooks && orama.beforeUpdate) {
    await runSingleHook(orama.beforeUpdate, orama, id);
  }
  await remove5(orama, id, language, skipHooks);
  const newId = await insert5(orama, doc, language, skipHooks);
  if (!skipHooks && orama.afterUpdate) {
    await runSingleHook(orama.afterUpdate, orama, newId);
  }
  return newId;
}
async function updateMultiple(orama, ids, docs, batchSize, language, skipHooks) {
  if (!skipHooks) {
    await runMultipleHook(orama.beforeMultipleUpdate, orama, ids);
  }
  const docsLength = docs.length;
  for (let i = 0; i < docsLength; i++) {
    const errorProperty = await orama.validateSchema(docs[i], orama.schema);
    if (errorProperty) {
      throw createError("SCHEMA_VALIDATION_FAILURE", errorProperty);
    }
  }
  await removeMultiple(orama, ids, batchSize, language, skipHooks);
  const newIds = await innerInsertMultiple(orama, docs, batchSize, language, skipHooks);
  if (!skipHooks) {
    await runMultipleHook(orama.afterMultipleUpdate, orama, newIds);
  }
  return newIds;
}

// node_modules/@orama/orama/dist/internals.js
var internals_exports = {};
__export(internals_exports, {
  avl: () => avl_exports,
  boundedLevenshtein: () => boundedLevenshtein,
  formatBytes: () => formatBytes,
  formatNanoseconds: () => formatNanoseconds,
  getNanosecondsTime: () => getNanosecondsTime,
  radixTree: () => radix_exports,
  uniqueId: () => uniqueId
});
export {
  components_exports2 as components,
  count2 as count,
  create6 as create,
  getByID,
  insert5 as insert,
  insertMultiple,
  internals_exports as internals,
  kInsertions,
  kRemovals,
  load5 as load,
  remove5 as remove,
  removeMultiple,
  save5 as save,
  search2 as search,
  update,
  updateMultiple
};
//# sourceMappingURL=@orama_orama.js.map
