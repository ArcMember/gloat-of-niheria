{
  "version": 3,
  "sources": ["../../@orama/orama/src/components/tokenizer/languages.ts", "../../@orama/orama/src/utils.ts", "../../@orama/orama/src/errors.ts", "../../@orama/orama/src/components/defaults.ts", "../../@orama/orama/src/components/documents-store.ts", "../../@orama/orama/src/components/internal-document-id-store.ts", "../../@orama/orama/src/components/hooks.ts", "../../@orama/orama/src/components/index.ts", "../../@orama/orama/src/trees/avl.ts", "../../@orama/orama/src/trees/radix.ts", "../../@orama/orama/src/components/levenshtein.ts", "../../@orama/orama/src/components/algorithms.ts", "../../@orama/orama/src/components/tokenizer/index.ts", "../../@orama/orama/src/components/tokenizer/diacritics.ts", "../../@orama/orama/src/components/tokenizer/english-stemmer.ts", "../../@orama/orama/src/components/sorter.ts", "../../@orama/orama/src/methods/create.ts", "../../@orama/orama/src/methods/docs.ts", "../../@orama/orama/src/components.ts", "../../@orama/orama/src/types.ts", "../../@orama/orama/src/components/sync-blocking-checker.ts", "../../@orama/orama/src/methods/insert.ts", "../../@orama/orama/src/methods/remove.ts", "../../@orama/orama/src/components/facets.ts", "../../@orama/orama/src/components/filters.ts", "../../@orama/orama/src/components/groups.ts", "../../@orama/orama/src/methods/search.ts", "../../@orama/orama/src/methods/serialization.ts", "../../@orama/orama/src/methods/update.ts", "../../@orama/orama/src/internals.ts"],
  "sourcesContent": ["export const STEMMERS: Record<string, string> = {\n  arabic: 'ar',\n  armenian: 'am',\n  bulgarian: 'bg',\n  danish: 'dk',\n  dutch: 'nl',\n  english: 'en',\n  finnish: 'fi',\n  french: 'fr',\n  german: 'de',\n  greek: 'gr',\n  hungarian: 'hu',\n  indian: 'in',\n  indonesian: 'id',\n  irish: 'ie',\n  italian: 'it',\n  lithuanian: 'lt',\n  nepali: 'np',\n  norwegian: 'no',\n  portuguese: 'pt',\n  romanian: 'ro',\n  russian: 'ru',\n  serbian: 'rs',\n  slovenian: 'ru',\n  spanish: 'es',\n  swedish: 'se',\n  tamil: 'ta',\n  turkish: 'tr',\n  ukrainian: 'uk',\n}\n\nexport const SPLITTERS: Record<Language, RegExp> = {\n  dutch: /[^A-Za-zàèéìòóù0-9_'-]+/gim,\n  english: /[^A-Za-zàèéìòóù0-9_'-]+/gim,\n  french: /[^a-z0-9äâàéèëêïîöôùüûœç-]+/gim,\n  italian: /[^A-Za-zàèéìòóù0-9_'-]+/gim,\n  norwegian: /[^a-z0-9_æøåÆØÅäÄöÖüÜ]+/gim,\n  portuguese: /[^a-z0-9à-úÀ-Ú]/gim,\n  russian: /[^a-z0-9а-яА-ЯёЁ]+/gim,\n  spanish: /[^a-z0-9A-Zá-úÁ-ÚñÑüÜ]+/gim,\n  swedish: /[^a-z0-9_åÅäÄöÖüÜ-]+/gim,\n  german: /[^a-z0-9A-ZäöüÄÖÜß]+/gim,\n  finnish: /[^a-z0-9äöÄÖ]+/gim,\n  danish: /[^a-z0-9æøåÆØÅ]+/gim,\n  hungarian: /[^a-z0-9áéíóöőúüűÁÉÍÓÖŐÚÜŰ]+/gim,\n  romanian: /[^a-z0-9ăâîșțĂÂÎȘȚ]+/gim,\n  serbian: /[^a-z0-9čćžšđČĆŽŠĐ]+/gim,\n  turkish: /[^a-z0-9çÇğĞıİöÖşŞüÜ]+/gim,\n  lithuanian: /[^a-z0-9ąčęėįšųūžĄČĘĖĮŠŲŪŽ]+/gim,\n  arabic: /[^a-z0-9أ-ي]+/gim,\n  nepali: /[^a-z0-9अ-ह]+/gim,\n  irish: /[^a-z0-9áéíóúÁÉÍÓÚ]+/gim,\n  indian: /[^a-z0-9अ-ह]+/gim,\n  armenian: /[^a-z0-9ա-ֆ]+/gim,\n  greek: /[^a-z0-9α-ωά-ώ]+/gim,\n  indonesian: /[^a-z0-9]+/gim,\n  ukrainian: /[^a-z0-9а-яА-ЯіїєІЇЄ]+/gim,\n  slovenian: /[^a-z0-9čžšČŽŠ]+/gim,\n  bulgarian: /[^a-z0-9а-яА-Я]+/gim,\n  tamil: /[^a-z0-9அ-ஹ]+/gim,\n}\n\nexport const SUPPORTED_LANGUAGES = Object.keys(STEMMERS)\n\nexport type Language = typeof SUPPORTED_LANGUAGES[number]\n", "import type { Document, SearchableValue, TokenScore } from './types.js'\n\nconst baseId = Date.now().toString().slice(5)\nlet lastId = 0\n\nconst k = 1024\nconst nano = BigInt(1e3)\nconst milli = BigInt(1e6)\nconst second = BigInt(1e9)\n\nexport const isServer = typeof window === 'undefined'\n\nexport function sprintf(template: string, ...args: (string | number)[]): string {\n  return template.replace(\n    /%(?:(?<position>\\d+)\\$)?(?<width>-?\\d*\\.?\\d*)(?<type>[dfs])/g,\n    function (...replaceArgs: Array<string | number | Record<string, string>>): string {\n      const groups = replaceArgs[replaceArgs.length - 1] as Record<string, string>\n      const { width: rawWidth, type, position } = groups\n\n      const replacement = position ? args[Number.parseInt(position) - 1]! : args.shift()!\n      const width = rawWidth === '' ? 0 : Number.parseInt(rawWidth)\n\n      switch (type) {\n        case 'd':\n          return replacement.toString().padStart(width, '0')\n        case 'f': {\n          let value = replacement\n          const [padding, precision] = rawWidth.split('.').map(w => Number.parseFloat(w))\n\n          if (typeof precision === 'number' && precision >= 0) {\n            value = (value as number).toFixed(precision)\n          }\n\n          return typeof padding === 'number' && padding >= 0 ? value.toString().padStart(width, '0') : value.toString()\n        }\n        case 's':\n          return width < 0\n            ? (replacement as string).toString().padEnd(-width, ' ')\n            : (replacement as string).toString().padStart(width, ' ')\n\n        default:\n          return replacement as string\n      }\n    },\n  )\n}\n\nexport async function formatBytes(bytes: number, decimals = 2): Promise<string> {\n  if (bytes === 0) {\n    return '0 Bytes'\n  }\n  const dm = decimals < 0 ? 0 : decimals\n  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']\n  const i = Math.floor(Math.log(bytes) / Math.log(k))\n  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`\n}\n\nexport async function formatNanoseconds(value: number | bigint): Promise<string> {\n  if (typeof value === 'number') {\n    value = BigInt(value)\n  }\n\n  if (value < nano) {\n    return `${value}ns`\n  } else if (value < milli) {\n    return `${value / nano}μs`\n  } else if (value < second) {\n    return `${value / milli}ms`\n  }\n\n  return `${value / second}s`\n}\n\nexport async function getNanosecondsTime(): Promise<bigint> {\n  if (typeof process !== 'undefined' && process.hrtime !== undefined) {\n    return process.hrtime.bigint()\n  }\n\n  if (typeof performance !== 'undefined') {\n    return BigInt(Math.floor(performance.now() * 1e6))\n  }\n\n  // @todo: fallback to V8 native method to get microtime\n  return BigInt(0)\n}\n\nexport async function uniqueId(): Promise<string> {\n  return `${baseId}-${lastId++}`\n}\n\nexport function getOwnProperty<T = unknown>(object: Record<string, T>, property: string): T | undefined {\n  // Checks if `hasOwn` method is defined avoiding errors with older Node.js versions\n  if (Object.hasOwn === undefined) {\n    return Object.prototype.hasOwnProperty.call(object, property) ? object[property] : undefined\n  }\n\n  return Object.hasOwn(object, property) ? object[property] : undefined\n}\n\nexport function getTokenFrequency(token: string, tokens: string[]): number {\n  let count = 0\n\n  for (const t of tokens) {\n    if (t === token) {\n      count++\n    }\n  }\n\n  return count\n}\n\nexport function insertSortedValue(\n  arr: TokenScore[],\n  el: TokenScore,\n  compareFn = sortTokenScorePredicate,\n): TokenScore[] {\n  let low = 0\n  let high = arr.length\n  let mid\n\n  while (low < high) {\n    mid = (low + high) >>> 1\n    if (compareFn(el, arr[mid]) < 0) {\n      high = mid\n    } else {\n      low = mid + 1\n    }\n  }\n\n  arr.splice(low, 0, el)\n\n  return arr\n}\n\nexport function sortTokenScorePredicate(a: TokenScore, b: TokenScore): number {\n  if (b[1] === a[1]) {\n    return a[0] - b[0]\n  }\n\n  return b[1] - a[1]\n}\n\n// Intersection function taken from https://github.com/lovasoa/fast_array_intersect.\n// MIT Licensed at the time of writing.\nexport function intersect<T>(arrays: ReadonlyArray<T>[]): T[] {\n  if (arrays.length === 0) {\n    return []\n  } else if (arrays.length === 1) {\n    return arrays[0] as T[]\n  }\n\n  for (let i = 1; i < arrays.length; i++) {\n    if (arrays[i].length < arrays[0].length) {\n      const tmp = arrays[0]\n      arrays[0] = arrays[i]\n      arrays[i] = tmp\n    }\n  }\n\n  const set = new Map()\n  for (const elem of arrays[0]) {\n    set.set(elem, 1)\n  }\n  for (let i = 1; i < arrays.length; i++) {\n    let found = 0\n    for (const elem of arrays[i]) {\n      const count = set.get(elem)\n      if (count === i) {\n        set.set(elem, count + 1)\n        found++\n      }\n    }\n    if (found === 0) return []\n  }\n\n  return arrays[0].filter(e => {\n    const count = set.get(e)\n    if (count !== undefined) set.set(e, 0)\n    return count === arrays.length\n  })\n}\n\nexport async function getDocumentProperties(doc: Document, paths: string[]): Promise<Record<string, SearchableValue>> {\n  const properties: Record<string, SearchableValue> = {}\n\n  const pathsLength = paths.length\n  for (let i = 0; i < pathsLength; i++) {\n    const path = paths[i]\n    const pathTokens = path.split('.')\n\n    let current: SearchableValue | Document | undefined = doc\n    const pathTokensLength = pathTokens.length\n    for (let j = 0; j < pathTokensLength; j++) {\n      current = (current as Document)[pathTokens[j]!] as Document | SearchableValue\n\n      // We found an object but we were supposed to be done\n      if (typeof current === 'object' && !Array.isArray(current) && current !== null && j === pathTokensLength - 1) {\n        current = undefined\n        break\n      } else if ((current === null || typeof current !== 'object') && j < pathTokensLength - 1) {\n        // We can't recurse anymore but we were supposed to\n        current = undefined\n        break\n      }\n    }\n\n    if (typeof current !== 'undefined') {\n      properties[path] = current as SearchableValue\n    }\n  }\n\n  return properties\n}\n\nexport async function getNested<T = SearchableValue>(obj: object, path: string): Promise<T | undefined> {\n  const props = await getDocumentProperties(obj as Document, [path])\n\n  return props[path] as T | undefined\n}\n\nexport function flattenObject(obj: object, prefix = ''): Document {\n  const result: Document = {}\n\n  for (const key in obj) {\n    const prop = `${prefix}${key}`\n    const objKey = (obj as Document)[key]\n\n    if (typeof objKey === 'object' && objKey !== null) {\n      Object.assign(result, flattenObject(objKey, `${prop}.`))\n    } else {\n      result[prop] = objKey\n    }\n  }\n  return result\n}\n", "import { SUPPORTED_LANGUAGES } from './components/tokenizer/languages.js'\nimport { sprintf } from './utils.js'\n\nconst allLanguages = SUPPORTED_LANGUAGES.join('\\n - ')\n\nconst errors = {\n  NO_LANGUAGE_WITH_CUSTOM_TOKENIZER: 'Do not pass the language option to create when using a custom tokenizer.',\n  LANGUAGE_NOT_SUPPORTED: `Language \"%s\" is not supported.\\nSupported languages are:\\n - ${allLanguages}`,\n  INVALID_STEMMER_FUNCTION_TYPE: `config.stemmer property must be a function.`,\n  MISSING_STEMMER: `As of version 1.0.0 @orama/orama does not ship non English stemmers by default. To solve this, please explicitly import and specify the \"%s\" stemmer from the package @orama/stemmers. See https://docs.oramasearch.com/text-analysis/stemming for more information.`,\n  CUSTOM_STOP_WORDS_MUST_BE_FUNCTION_OR_ARRAY: 'Custom stop words array must only contain strings.',\n  UNSUPPORTED_COMPONENT: `Unsupported component \"%s\".`,\n  COMPONENT_MUST_BE_FUNCTION: `The component \"%s\" must be a function.`,\n  COMPONENT_MUST_BE_FUNCTION_OR_ARRAY_FUNCTIONS: `The component \"%s\" must be a function or an array of functions.`,\n  INVALID_SCHEMA_TYPE: `Unsupported schema type \"%s\" at \"%s\". Expected \"string\", \"boolean\" or \"number\" or array of them.`,\n  DOCUMENT_ID_MUST_BE_STRING: `Document id must be of type \"string\". Got \"%s\" instead.`,\n  DOCUMENT_ALREADY_EXISTS: `A document with id \"%s\" already exists.`,\n  DOCUMENT_DOES_NOT_EXIST: `A document with id \"%s\" does not exists.`,\n  MISSING_DOCUMENT_PROPERTY: `Missing searchable property \"%s\".`,\n  INVALID_DOCUMENT_PROPERTY: `Invalid document property \"%s\": expected \"%s\", got \"%s\"`,\n  UNKNOWN_INDEX: `Invalid property name \"%s\". Expected a wildcard string (\"*\") or array containing one of the following properties: %s`,\n  INVALID_BOOST_VALUE: `Boost value must be a number greater than, or less than 0.`,\n  INVALID_FILTER_OPERATION: `You can only use one operation per filter, you requested %d.`,\n  SCHEMA_VALIDATION_FAILURE: `Cannot insert document due schema validation failure on \"%s\" property.`,\n  INVALID_SORT_SCHEMA_TYPE: `Unsupported sort schema type \"%s\" at \"%s\". Expected \"string\" or \"number\".`,\n  CANNOT_SORT_BY_ARRAY: `Cannot configure sort for \"%s\" because it is an array (%s).`,\n  UNABLE_TO_SORT_ON_UNKNOWN_FIELD: `Unable to sort on unknown field \"%s\". Allowed fields: %s`,\n  SORT_DISABLED: `Sort is disabled. Please read the documentation at https://docs.oramasearch for more information.`,\n  UNKNOWN_GROUP_BY_PROPERTY: `Unknown groupBy property \"%s\".`,\n  INVALID_GROUP_BY_PROPERTY: `Invalid groupBy property \"%s\". Allowed types: \"%s\", but given \"%s\".`,\n  UNKNOWN_FILTER_PROPERTY: `Unknown filter property \"%s\".`,\n}\n\nexport type ErrorCode = keyof typeof errors\n\nexport interface OramaError extends Error {\n  code: string\n}\n\nexport function createError(code: ErrorCode, ...args: Array<string | number>): OramaError {\n  const error = new Error(sprintf(errors[code] ?? `Unsupported Orama Error code: ${code}`, ...args)) as OramaError\n  error.code = code\n  if ('captureStackTrace' in Error.prototype) {\n    Error.captureStackTrace(error)\n  }\n\n  return error\n}\n", "import { createError } from '../errors.js'\nimport { ArraySearchableType, Document, ElapsedTime, ScalarSearchableType, Schema, SearchableType } from '../types.js'\nimport { uniqueId, formatNanoseconds } from '../utils.js'\n\nexport { getDocumentProperties } from '../utils.js'\n\nexport async function formatElapsedTime(n: bigint): Promise<ElapsedTime> {\n  return {\n    raw: Number(n),\n    formatted: await formatNanoseconds(n),\n  }\n}\n\nexport async function getDocumentIndexId(doc: Document): Promise<string> {\n  if (doc.id) {\n    if (typeof doc.id !== 'string') {\n      throw createError('DOCUMENT_ID_MUST_BE_STRING', typeof doc.id)\n    }\n\n    return doc.id\n  }\n\n  return await uniqueId()\n}\n\nexport async function validateSchema<S extends Schema = Schema>(doc: Document, schema: S): Promise<string | undefined> {\n  for (const [prop, type] of Object.entries(schema)) {\n    const value = doc[prop]\n    const typeOfValue = typeof value\n\n    if (typeOfValue === 'undefined') {\n      continue\n    }\n\n    const typeOfType = typeof type\n\n    if (typeOfType === 'string' && isArrayType(type as SearchableType)) {\n      if (!Array.isArray(value)) {\n        return prop\n      }\n      const expectedType = getInnerType(type as ArraySearchableType)\n\n      const valueLength = value.length\n      for (let i = 0; i < valueLength; i++) {\n        if (typeof value[i] !== expectedType) {\n          return prop + '.' + i\n        }\n      }\n\n      continue\n    }\n\n    if (typeOfType === 'object') {\n      if (!value || typeOfValue !== 'object') {\n        return prop\n      }\n\n      const subProp = await validateSchema(value as Document, type as Schema)\n      if (subProp) {\n        return prop + '.' + subProp\n      }\n      continue\n    }\n\n    if (typeOfValue !== type) {\n      return prop\n    }\n  }\n\n  return undefined\n}\n\nconst IS_ARRAY_TYPE: Record<SearchableType, boolean> = {\n  string: false,\n  number: false,\n  boolean: false,\n  'string[]': true,\n  'number[]': true,\n  'boolean[]': true,\n}\nconst INNER_TYPE: Record<ArraySearchableType, ScalarSearchableType> = {\n  'string[]': 'string',\n  'number[]': 'number',\n  'boolean[]': 'boolean',\n}\nexport function isArrayType(type: SearchableType) {\n  return IS_ARRAY_TYPE[type]\n}\nexport function getInnerType(type: ArraySearchableType): ScalarSearchableType {\n  return INNER_TYPE[type]\n}\n", "import {\n  DocumentID,\n  getInternalDocumentId,\n  InternalDocumentID,\n  InternalDocumentIDStore,\n} from './internal-document-id-store.js'\nimport { Document, IDocumentsStore, OpaqueDocumentStore, Orama } from '../types.js'\n\nexport interface DocumentsStore extends OpaqueDocumentStore {\n  sharedInternalDocumentStore: InternalDocumentIDStore\n  docs: Record<InternalDocumentID, Document | undefined>\n  count: number\n}\n\nexport type DefaultDocumentsStore = IDocumentsStore<DocumentsStore>\n\nexport async function create(_: Orama, sharedInternalDocumentStore: InternalDocumentIDStore): Promise<DocumentsStore> {\n  return {\n    sharedInternalDocumentStore,\n    docs: {},\n    count: 0,\n  }\n}\n\nexport async function get(store: DocumentsStore, id: DocumentID): Promise<Document | undefined> {\n  const internalId = getInternalDocumentId(store.sharedInternalDocumentStore, id)\n\n  return store.docs[internalId]\n}\n\nexport async function getMultiple(store: DocumentsStore, ids: DocumentID[]): Promise<(Document | undefined)[]> {\n  const found: (Document | undefined)[] = Array.from({ length: ids.length })\n\n  for (let i = 0; i < ids.length; i++) {\n    const internalId = getInternalDocumentId(store.sharedInternalDocumentStore, ids[i])\n    found[i] = store.docs[internalId]\n  }\n\n  return found\n}\n\nexport async function getAll(store: DocumentsStore): Promise<Record<InternalDocumentID, Document>> {\n  return store.docs as Record<InternalDocumentID, Document>\n}\n\nexport async function store(store: DocumentsStore, id: DocumentID, doc: Document): Promise<boolean> {\n  const internalId = getInternalDocumentId(store.sharedInternalDocumentStore, id)\n\n  if (typeof store.docs[internalId] !== 'undefined') {\n    return false\n  }\n\n  store.docs[internalId] = doc\n  store.count++\n\n  return true\n}\n\nexport async function remove(store: DocumentsStore, id: DocumentID): Promise<boolean> {\n  const internalId = getInternalDocumentId(store.sharedInternalDocumentStore, id)\n\n  if (typeof store.docs[internalId] === 'undefined') {\n    return false\n  }\n\n  delete store.docs[internalId]\n  store.count--\n\n  return true\n}\n\nexport async function count(store: DocumentsStore): Promise<number> {\n  return store.count\n}\n\nexport async function load<R = unknown>(\n  sharedInternalDocumentStore: InternalDocumentIDStore,\n  raw: R,\n): Promise<DocumentsStore> {\n  const rawDocument = raw as DocumentsStore\n\n  return {\n    docs: rawDocument.docs,\n    count: rawDocument.count,\n    sharedInternalDocumentStore,\n  }\n}\n\nexport async function save<R = unknown>(store: DocumentsStore): Promise<R> {\n  return {\n    docs: store.docs,\n    count: store.count,\n  } as R\n}\n\nexport async function createDocumentsStore(): Promise<DefaultDocumentsStore> {\n  return {\n    create,\n    get,\n    getMultiple,\n    getAll,\n    store,\n    remove,\n    count,\n    load,\n    save,\n  }\n}\n", "import { Orama } from '../types.js'\n\nexport type DocumentID = string | number\nexport type InternalDocumentID = number\n\nexport type InternalDocumentIDStore = {\n  idToInternalId: Map<string, number>\n  internalIdToId: string[]\n  save: (store: InternalDocumentIDStore) => unknown\n  load: (orama: Orama, raw: unknown) => void\n}\n\nexport function createInternalDocumentIDStore(): InternalDocumentIDStore {\n  return {\n    idToInternalId: new Map(),\n    internalIdToId: [],\n    save,\n    load,\n  }\n}\n\nexport function save(store: InternalDocumentIDStore): unknown {\n  return {\n    internalIdToId: store.internalIdToId,\n  }\n}\n\nexport function load(orama: Orama, raw: unknown): void {\n  const { internalIdToId } = raw as InternalDocumentIDStore\n\n  orama.internalDocumentIDStore.idToInternalId.clear()\n  orama.internalDocumentIDStore.internalIdToId = []\n\n  for (let i = 0; i < internalIdToId.length; i++) {\n    orama.internalDocumentIDStore.idToInternalId.set(internalIdToId[i], i + 1)\n    orama.internalDocumentIDStore.internalIdToId.push(internalIdToId[i])\n  }\n}\n\nexport function getInternalDocumentId(store: InternalDocumentIDStore, id: DocumentID): InternalDocumentID {\n  if (typeof id === 'string') {\n    const internalId = store.idToInternalId.get(id)\n\n    if (internalId) {\n      return internalId\n    }\n\n    const currentId = store.idToInternalId.size + 1\n\n    store.idToInternalId.set(id, currentId)\n    store.internalIdToId.push(id)\n\n    return currentId\n  }\n\n  if (id > store.internalIdToId.length) {\n    return getInternalDocumentId(store, id.toString())\n  }\n\n  return id\n}\n\nexport function getDocumentIdFromInternalId(store: InternalDocumentIDStore, internalId: InternalDocumentID): string {\n  if (store.internalIdToId.length < internalId) {\n    throw new Error(`Invalid internalId ${internalId}`)\n  }\n\n  return store.internalIdToId[internalId - 1]\n}\n", "import {\n  AfterSearch,\n  Document,\n  MultipleCallbackComponent,\n  Orama,\n  ProvidedTypes,\n  Results,\n  SearchParams,\n  SingleCallbackComponent,\n} from '../types.js'\n\nexport const OBJECT_COMPONENTS = ['tokenizer', 'index', 'documentsStore', 'sorter']\n\nexport const FUNCTION_COMPONENTS = [\n  'validateSchema',\n  'getDocumentIndexId',\n  'getDocumentProperties',\n  'formatElapsedTime',\n]\n\nexport const SINGLE_OR_ARRAY_COMPONENTS = [\n  'beforeInsert',\n  'afterInsert',\n  'beforeRemove',\n  'afterRemove',\n  'beforeUpdate',\n  'afterUpdate',\n  'afterSearch',\n  'beforeMultipleInsert',\n  'afterMultipleInsert',\n  'beforeMultipleRemove',\n  'afterMultipleRemove',\n  'beforeMultipleUpdate',\n  'afterMultipleUpdate',\n]\n\nexport async function runSingleHook<P extends ProvidedTypes>(\n  hooks: SingleCallbackComponent<P>[],\n  orama: Orama<P>,\n  id: string,\n  doc?: Document,\n): Promise<void> {\n  const hooksLength = hooks.length\n  for (let i = 0; i < hooksLength; i++) {\n    await hooks[i](orama, id, doc)\n  }\n}\n\nexport async function runMultipleHook<P extends ProvidedTypes>(\n  hooks: MultipleCallbackComponent<P>[],\n  orama: Orama<P>,\n  docsOrIds: Document[] | string[],\n): Promise<void> {\n  const hooksLength = hooks.length\n  for (let i = 0; i < hooksLength; i++) {\n    await hooks[i](orama, docsOrIds)\n  }\n}\n\nexport async function runAfterSearch<P extends ProvidedTypes, AggValue>(\n  hooks: AfterSearch<P>[],\n  db: Orama<P>,\n  params: SearchParams<AggValue>,\n  language: string | undefined,\n  results: Results<AggValue>,\n): Promise<void> {\n  const hooksLength = hooks.length\n  for (let i = 0; i < hooksLength; i++) {\n    await hooks[i](db, params, language, results)\n  }\n}\n", "import { createError } from '../errors.js'\nimport {\n  create as avlCreate,\n  find as avlFind,\n  greaterThan as avlGreaterThan,\n  insert as avlInsert,\n  lessThan as avlLessThan,\n  Node as AVLNode,\n  rangeSearch as avlRangeSearch,\n  removeDocument as avlRemoveDocument,\n} from '../trees/avl.js'\nimport {\n  create as radixCreate,\n  find as radixFind,\n  insert as radixInsert,\n  Node as RadixNode,\n  removeDocumentByWord as radixRemoveDocument,\n} from '../trees/radix.js'\nimport {\n  ArraySearchableType,\n  BM25Params,\n  ComparisonOperator,\n  IIndex,\n  OpaqueDocumentStore,\n  OpaqueIndex,\n  Orama,\n  ScalarSearchableType,\n  Schema,\n  SearchableType,\n  SearchableValue,\n  SearchContext,\n  Tokenizer,\n  TokenScore,\n} from '../types.js'\nimport { intersect } from '../utils.js'\nimport { BM25 } from './algorithms.js'\nimport { getInnerType, isArrayType } from './defaults.js'\nimport {\n  DocumentID,\n  getInternalDocumentId,\n  InternalDocumentID,\n  InternalDocumentIDStore,\n} from './internal-document-id-store.js'\n\nexport type FrequencyMap = {\n  [property: string]: {\n    [documentID: InternalDocumentID]:\n      | {\n          [token: string]: number\n        }\n      | undefined\n  }\n}\n\nexport type BooleanIndex = {\n  true: InternalDocumentID[]\n  false: InternalDocumentID[]\n}\n\nexport interface Index extends OpaqueIndex {\n  sharedInternalDocumentStore: InternalDocumentIDStore\n  indexes: Record<string, RadixNode | AVLNode<number, InternalDocumentID[]> | BooleanIndex>\n  searchableProperties: string[]\n  searchablePropertiesWithTypes: Record<string, SearchableType>\n  frequencies: FrequencyMap\n  tokenOccurrences: Record<string, Record<string, number>>\n  avgFieldLength: Record<string, number>\n  fieldLengths: Record<string, Record<InternalDocumentID, number | undefined>>\n}\n\nexport type DefaultIndex = IIndex<Index>\n\nexport async function insertDocumentScoreParameters(\n  index: Index,\n  prop: string,\n  id: DocumentID,\n  tokens: string[],\n  docsCount: number,\n): Promise<void> {\n  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id)\n\n  index.avgFieldLength[prop] = ((index.avgFieldLength[prop] ?? 0) * (docsCount - 1) + tokens.length) / docsCount\n  index.fieldLengths[prop][internalId] = tokens.length\n  index.frequencies[prop][internalId] = {}\n}\n\nexport async function insertTokenScoreParameters(\n  index: Index,\n  prop: string,\n  id: DocumentID,\n  tokens: string[],\n  token: string,\n): Promise<void> {\n  let tokenFrequency = 0\n\n  for (const t of tokens) {\n    if (t === token) {\n      tokenFrequency++\n    }\n  }\n\n  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id)\n  const tf = tokenFrequency / tokens.length\n\n  index.frequencies[prop][internalId]![token] = tf\n\n  if (!(token in index.tokenOccurrences[prop])) {\n    index.tokenOccurrences[prop][token] = 0\n  }\n\n  // increase a token counter that may not yet exist\n  index.tokenOccurrences[prop][token] = (index.tokenOccurrences[prop][token] ?? 0) + 1\n}\n\nexport async function removeDocumentScoreParameters(\n  index: Index,\n  prop: string,\n  id: DocumentID,\n  docsCount: number,\n): Promise<void> {\n  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id)\n\n  index.avgFieldLength[prop] =\n    (index.avgFieldLength[prop] * docsCount - index.fieldLengths[prop][internalId]!) / (docsCount - 1)\n  index.fieldLengths[prop][internalId] = undefined\n  index.frequencies[prop][internalId] = undefined\n}\n\nexport async function removeTokenScoreParameters(index: Index, prop: string, token: string): Promise<void> {\n  index.tokenOccurrences[prop][token]--\n}\n\nexport async function calculateResultScores<I extends OpaqueIndex, D extends OpaqueDocumentStore, AggValue>(\n  context: SearchContext<I, D, AggValue>,\n  index: Index,\n  prop: string,\n  term: string,\n  ids: DocumentID[],\n): Promise<TokenScore[]> {\n  const documentIDs = Array.from(ids)\n\n  // Exact fields for TF-IDF\n  const avgFieldLength = index.avgFieldLength[prop]\n  const fieldLengths = index.fieldLengths[prop]\n  const oramaOccurrences = index.tokenOccurrences[prop]\n  const oramaFrequencies = index.frequencies[prop]\n\n  // oramaOccurrences[term] can be undefined, 0, string, or { [k: string]: number }\n  const termOccurrences = typeof oramaOccurrences[term] === 'number' ? oramaOccurrences[term] ?? 0 : 0\n\n  const scoreList: TokenScore[] = []\n\n  // Calculate TF-IDF value for each term, in each document, for each index.\n  const documentIDsLength = documentIDs.length\n  for (let k = 0; k < documentIDsLength; k++) {\n    const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, documentIDs[k])\n    const tf = oramaFrequencies?.[internalId]?.[term] ?? 0\n\n    const bm25 = BM25(\n      tf,\n      termOccurrences,\n      context.docsCount,\n      fieldLengths[internalId]!,\n      avgFieldLength,\n      context.params.relevance! as Required<BM25Params>,\n    )\n\n    scoreList.push([internalId, bm25])\n  }\n  return scoreList\n}\n\nexport async function create(\n  orama: Orama<{ Index: DefaultIndex }>,\n  sharedInternalDocumentStore: InternalDocumentIDStore,\n  schema: Schema,\n  index?: Index,\n  prefix = '',\n): Promise<Index> {\n  if (!index) {\n    index = {\n      sharedInternalDocumentStore,\n      indexes: {},\n      searchableProperties: [],\n      searchablePropertiesWithTypes: {},\n      frequencies: {},\n      tokenOccurrences: {},\n      avgFieldLength: {},\n      fieldLengths: {},\n    }\n  }\n\n  for (const [prop, type] of Object.entries(schema)) {\n    const typeActualType = typeof type\n    const path = `${prefix}${prefix ? '.' : ''}${prop}`\n\n    if (typeActualType === 'object' && !Array.isArray(type)) {\n      // Nested\n      create(orama, sharedInternalDocumentStore, type as Schema, index, path)\n      continue\n    }\n\n    switch (type) {\n      case 'boolean':\n      case 'boolean[]':\n        index.indexes[path] = { true: [], false: [] }\n        break\n      case 'number':\n      case 'number[]':\n        index.indexes[path] = avlCreate<number, InternalDocumentID[]>(0, [])\n        break\n      case 'string':\n      case 'string[]':\n        index.indexes[path] = radixCreate()\n        index.avgFieldLength[path] = 0\n        index.frequencies[path] = {}\n        index.tokenOccurrences[path] = {}\n        index.fieldLengths[path] = {}\n        break\n      default:\n        throw createError('INVALID_SCHEMA_TYPE', Array.isArray(type) ? 'array' : (type as unknown as string), path)\n    }\n\n    index.searchableProperties.push(path)\n    index.searchablePropertiesWithTypes[path] = type\n  }\n\n  return index\n}\n\nasync function insertScalar(\n  implementation: IIndex<Index>,\n  index: Index,\n  prop: string,\n  id: DocumentID,\n  value: SearchableValue,\n  schemaType: ScalarSearchableType,\n  language: string | undefined,\n  tokenizer: Tokenizer,\n  docsCount: number,\n): Promise<void> {\n  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id)\n\n  switch (schemaType) {\n    case 'boolean': {\n      const booleanIndex = index.indexes[prop] as BooleanIndex\n      booleanIndex[value ? 'true' : 'false'].push(internalId)\n      break\n    }\n    case 'number':\n      avlInsert(index.indexes[prop] as AVLNode<number, number[]>, value as number, [internalId])\n      break\n    case 'string': {\n      const tokens = await tokenizer.tokenize(value as string, language, prop)\n      await implementation.insertDocumentScoreParameters(index, prop, internalId, tokens, docsCount)\n\n      for (const token of tokens) {\n        await implementation.insertTokenScoreParameters(index, prop, internalId, tokens, token)\n\n        radixInsert(index.indexes[prop] as RadixNode, token, internalId)\n      }\n\n      break\n    }\n  }\n}\n\nexport async function insert(\n  implementation: DefaultIndex,\n  index: Index,\n  prop: string,\n  id: DocumentID,\n  value: SearchableValue,\n  schemaType: SearchableType,\n  language: string | undefined,\n  tokenizer: Tokenizer,\n  docsCount: number,\n): Promise<void> {\n  if (!isArrayType(schemaType)) {\n    return insertScalar(\n      implementation,\n      index,\n      prop,\n      id,\n      value,\n      schemaType as ScalarSearchableType,\n      language,\n      tokenizer,\n      docsCount,\n    )\n  }\n\n  const innerSchemaType = getInnerType(schemaType as ArraySearchableType)\n\n  const elements = value as Array<string | number | boolean>\n  const elementsLength = elements.length\n  for (let i = 0; i < elementsLength; i++) {\n    await insertScalar(implementation, index, prop, id, elements[i], innerSchemaType, language, tokenizer, docsCount)\n  }\n}\n\nasync function removeScalar(\n  implementation: IIndex<Index>,\n  index: Index,\n  prop: string,\n  id: DocumentID,\n  value: SearchableValue,\n  schemaType: ScalarSearchableType,\n  language: string | undefined,\n  tokenizer: Tokenizer,\n  docsCount: number,\n): Promise<boolean> {\n  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id)\n\n  switch (schemaType) {\n    case 'number': {\n      avlRemoveDocument(index.indexes[prop] as AVLNode<number, InternalDocumentID[]>, internalId, value)\n      return true\n    }\n    case 'boolean': {\n      const booleanKey = value ? 'true' : 'false'\n      const position = (index.indexes[prop] as BooleanIndex)[booleanKey].indexOf(internalId)\n\n      ;(index.indexes[prop] as BooleanIndex)[value ? 'true' : 'false'].splice(position, 1)\n      return true\n    }\n    case 'string': {\n      const tokens = await tokenizer.tokenize(value as string, language, prop)\n\n      await implementation.removeDocumentScoreParameters(index, prop, id, docsCount)\n\n      for (const token of tokens) {\n        await implementation.removeTokenScoreParameters(index, prop, token)\n        radixRemoveDocument(index.indexes[prop] as RadixNode, token, internalId)\n      }\n\n      return true\n    }\n  }\n}\n\nexport async function remove(\n  implementation: DefaultIndex,\n  index: Index,\n  prop: string,\n  id: DocumentID,\n  value: SearchableValue,\n  schemaType: SearchableType,\n  language: string | undefined,\n  tokenizer: Tokenizer,\n  docsCount: number,\n): Promise<boolean> {\n  if (!isArrayType(schemaType)) {\n    return removeScalar(\n      implementation,\n      index,\n      prop,\n      id,\n      value,\n      schemaType as ScalarSearchableType,\n      language,\n      tokenizer,\n      docsCount,\n    )\n  }\n\n  const innerSchemaType = getInnerType(schemaType as ArraySearchableType)\n\n  const elements = value as Array<string | number | boolean>\n  const elementsLength = elements.length\n  for (let i = 0; i < elementsLength; i++) {\n    await removeScalar(implementation, index, prop, id, elements[i], innerSchemaType, language, tokenizer, docsCount)\n  }\n\n  return true\n}\n\nexport async function search<D extends OpaqueDocumentStore, AggValue>(\n  context: SearchContext<Index, D, AggValue>,\n  index: Index,\n  prop: string,\n  term: string,\n): Promise<TokenScore[]> {\n  if (!(prop in index.tokenOccurrences)) {\n    return []\n  }\n\n  // Performa the search\n  const rootNode = index.indexes[prop] as RadixNode\n  const { exact, tolerance } = context.params\n  const searchResult = radixFind(rootNode, { term, exact, tolerance })\n  const ids = new Set<InternalDocumentID>()\n\n  for (const key in searchResult) {\n    for (const id of searchResult[key]) {\n      ids.add(id)\n    }\n  }\n\n  return context.index.calculateResultScores(context, index, prop, term, Array.from(ids))\n}\n\nexport async function searchByWhereClause<I extends OpaqueIndex, D extends OpaqueDocumentStore, AggValue>(\n  context: SearchContext<I, D, AggValue>,\n  index: Index,\n  filters: Record<string, boolean | ComparisonOperator>,\n): Promise<number[]> {\n  const filterKeys = Object.keys(filters)\n\n  const filtersMap: Record<string, InternalDocumentID[]> = filterKeys.reduce(\n    (acc, key) => ({\n      [key]: [],\n      ...acc,\n    }),\n    {},\n  )\n\n  for (const param of filterKeys) {\n    const operation = filters[param]\n\n    if (typeof operation === 'boolean') {\n      const idx = index.indexes[param] as BooleanIndex\n\n      if (typeof idx === 'undefined') {\n        throw createError('UNKNOWN_FILTER_PROPERTY', param)\n      }\n\n      const filteredIDs = idx[operation.toString() as keyof BooleanIndex]\n      filtersMap[param].push(...filteredIDs)\n      continue\n    }\n\n    if (typeof operation === 'string' || Array.isArray(operation)) {\n      const idx = index.indexes[param] as RadixNode\n\n      if (typeof idx === 'undefined') {\n        throw createError('UNKNOWN_FILTER_PROPERTY', param)\n      }\n\n      for (const raw of [operation].flat()) {\n        const term = await context.tokenizer.tokenize(raw, context.language, param)\n        const filteredIDsResults = radixFind(idx, { term: term[0], exact: true })\n        filtersMap[param].push(...Object.values(filteredIDsResults).flat())\n      }\n\n      continue\n    }\n\n    const operationKeys = Object.keys(operation)\n\n    if (operationKeys.length > 1) {\n      throw createError('INVALID_FILTER_OPERATION', operationKeys.length)\n    }\n\n    const operationOpt = operationKeys[0] as keyof ComparisonOperator\n    const operationValue = operation[operationOpt]\n\n    const AVLNode = index.indexes[param] as AVLNode<number, InternalDocumentID[]>\n\n    if (typeof AVLNode === 'undefined') {\n      throw createError('UNKNOWN_FILTER_PROPERTY', param)\n    }\n\n    switch (operationOpt) {\n      case 'gt': {\n        const filteredIDs = avlGreaterThan(AVLNode, operationValue, false)\n        filtersMap[param].push(...filteredIDs)\n        break\n      }\n      case 'gte': {\n        const filteredIDs = avlGreaterThan(AVLNode, operationValue, true)\n        filtersMap[param].push(...filteredIDs)\n        break\n      }\n      case 'lt': {\n        const filteredIDs = avlLessThan(AVLNode, operationValue, false)\n        filtersMap[param].push(...filteredIDs)\n        break\n      }\n      case 'lte': {\n        const filteredIDs = avlLessThan(AVLNode, operationValue, true)\n        filtersMap[param].push(...filteredIDs)\n        break\n      }\n      case 'eq': {\n        const filteredIDs = avlFind(AVLNode, operationValue) ?? []\n        filtersMap[param].push(...filteredIDs)\n        break\n      }\n      case 'between': {\n        const [min, max] = operationValue as number[]\n        const filteredIDs = avlRangeSearch(AVLNode, min, max)\n        filtersMap[param].push(...filteredIDs)\n      }\n    }\n  }\n\n  // AND operation: calculate the intersection between all the IDs in filterMap\n  const result = intersect(Object.values(filtersMap))\n\n  return result\n}\n\nexport async function getSearchableProperties(index: Index): Promise<string[]> {\n  return index.searchableProperties\n}\n\nexport async function getSearchablePropertiesWithTypes(index: Index): Promise<Record<string, SearchableType>> {\n  return index.searchablePropertiesWithTypes\n}\n\nfunction loadNode(node: RadixNode): RadixNode {\n  const convertedNode = radixCreate(node.end, node.subWord, node.key)\n\n  convertedNode.docs = node.docs\n  convertedNode.word = node.word\n\n  for (const childrenKey of Object.keys(node.children)) {\n    convertedNode.children[childrenKey] = loadNode(node.children[childrenKey])\n  }\n\n  return convertedNode\n}\n\nexport async function load<R = unknown>(sharedInternalDocumentStore: InternalDocumentIDStore, raw: R): Promise<Index> {\n  const {\n    indexes: rawIndexes,\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrences,\n    avgFieldLength,\n    fieldLengths,\n  } = raw as Index\n\n  const indexes: Index['indexes'] = {}\n\n  for (const prop of Object.keys(rawIndexes)) {\n    const value = rawIndexes[prop]\n\n    if (!('word' in value)) {\n      indexes[prop] = value\n\n      continue\n    }\n\n    indexes[prop] = loadNode(value)\n  }\n\n  return {\n    sharedInternalDocumentStore,\n    indexes,\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrences,\n    avgFieldLength,\n    fieldLengths,\n  }\n}\n\nexport async function save<R = unknown>(index: Index): Promise<R> {\n  const {\n    indexes,\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrences,\n    avgFieldLength,\n    fieldLengths,\n  } = index\n\n  return {\n    indexes,\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrences,\n    avgFieldLength,\n    fieldLengths,\n  } as R\n}\n\nexport async function createIndex(): Promise<DefaultIndex> {\n  return {\n    create,\n    insert,\n    remove,\n    insertDocumentScoreParameters,\n    insertTokenScoreParameters,\n    removeDocumentScoreParameters,\n    removeTokenScoreParameters,\n    calculateResultScores,\n    search,\n    searchByWhereClause,\n    getSearchableProperties,\n    getSearchablePropertiesWithTypes,\n    load,\n    save,\n  }\n}\n", "export type Node<K, V> = {\n  key: K\n  value: V\n  left: Node<K, V> | null\n  right: Node<K, V> | null\n  height: number\n}\n\nconst BALANCE_STATE = {\n  UNBALANCED_RIGHT: -2,\n  SLIGHTLY_UNBALANCED_RIGHT: -1,\n  BALANCED: 0,\n  SLIGHTLY_UNBALANCED_LEFT: 1,\n  UNBALANCED_LEFT: 2,\n}\n\nfunction getHeight<K, V>(node: Node<K, V> | null): number {\n  return node ? node.height : -1\n}\n\nfunction rotateLeft<K, V>(node: Node<K, V>): Node<K, V> {\n  const right = node.right as Node<K, V>\n  node.right = right.left\n  right.left = node\n  node.height = Math.max(getHeight(node.left), getHeight(node.right)) + 1\n  right.height = Math.max(getHeight(right.left), getHeight(right.right)) + 1\n  return right\n}\n\nfunction rotateRight<K, V>(node: Node<K, V>): Node<K, V> {\n  const left = node.left as Node<K, V>\n  node.left = left.right\n  left.right = node\n  node.height = Math.max(getHeight(node.left), getHeight(node.right)) + 1\n  left.height = Math.max(getHeight(left.left), getHeight(left.right)) + 1\n  return left\n}\n\nexport function contains<K, V>(node: Node<K, V>, key: K): boolean {\n  return !!find(node, key)\n}\n\nexport function getSize<K, V>(root: Node<K, V> | null): number {\n  let size = 0\n  const queue: Array<Node<K, V>> = []\n\n  if (root !== null) {\n    queue.push(root)\n  }\n\n  while (queue.length > 0) {\n    const node = queue.shift() as Node<K, V>\n    size++\n\n    if (node.left !== null) {\n      queue.push(node.left)\n    }\n\n    if (node.right !== null) {\n      queue.push(node.right)\n    }\n  }\n\n  return size\n}\n\nexport function isBalanced<K, V>(root: Node<K, V> | null): boolean {\n  if (root === null) return true\n\n  const stack: Node<K, V>[] = [root]\n\n  while (stack.length > 0) {\n    const node = stack.pop()\n\n    if (node === undefined) return true\n\n    const heightDiff = getHeight(node.left) - getHeight(node.right)\n\n    if (heightDiff > 1 || heightDiff < -1) {\n      return false\n    }\n\n    if (node.right !== null) {\n      stack.push(node.right)\n    }\n\n    if (node.left !== null) {\n      stack.push(node.left)\n    }\n  }\n\n  return true\n}\n\nexport function rangeSearch<K, V>(node: Node<K, V>, min: K, max: K): V {\n  if (!node) {\n    return [] as unknown as V\n  }\n\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  const result: V[] = []\n\n  function traverse(node: Node<K, V>) {\n    if (!node) {\n      return\n    }\n\n    if (node.key > min) {\n      traverse(node.left as Node<K, V>)\n    }\n\n    if (node.key >= min && node.key <= max) {\n      result.push(...(node.value as V[]))\n    }\n\n    if (node.key < max) {\n      traverse(node.right as Node<K, V>)\n    }\n  }\n\n  traverse(node)\n\n  return result as V\n}\n\nexport function greaterThan<K, V>(node: Node<K, V>, key: K, inclusive = false): V {\n  if (!node) {\n    return [] as unknown as V\n  }\n\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  const result: V[] = []\n\n  function traverse(node: Node<K, V>) {\n    if (!node) {\n      return\n    }\n\n    if (inclusive && node.key >= key) {\n      result.push(...(node.value as V[]))\n    }\n\n    if (!inclusive && node.key > key) {\n      result.push(...(node.value as V[]))\n    }\n\n    traverse(node.left as Node<K, V>)\n    traverse(node.right as Node<K, V>)\n  }\n\n  traverse(node)\n\n  return result as V\n}\n\nexport function lessThan<K, V>(node: Node<K, V>, key: K, inclusive = false): V {\n  if (!node) {\n    return [] as unknown as V\n  }\n\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  const result: V[] = []\n\n  function traverse(node: Node<K, V>) {\n    if (!node) {\n      return\n    }\n\n    if (inclusive && node.key <= key) {\n      result.push(...(node.value as V[]))\n    }\n\n    if (!inclusive && node.key < key) {\n      result.push(...(node.value as V[]))\n    }\n\n    traverse(node.left as Node<K, V>)\n    traverse(node.right as Node<K, V>)\n  }\n\n  traverse(node)\n\n  return result as V\n}\n\nfunction getNodeByKey<K, V>(node: Node<K, V> | null, key: K): Node<K, V> | null {\n  while (node !== null) {\n    if (key < node.key) {\n      node = node.left\n    } else if (key > node.key) {\n      node = node.right\n    } else {\n      return node\n    }\n  }\n  return null\n}\n\nexport function create<K, V>(key: K, value: V): Node<K, V> {\n  return {\n    key,\n    value,\n    left: null,\n    right: null,\n    height: 0,\n  }\n}\n\nexport function insert<K, V>(root: Node<K, V>, key: K, value: V): Node<K, V> {\n  let parent = null\n  let current = root\n\n  while (current !== null) {\n    parent = current\n    if (key < current.key) {\n      current = current.left as Node<K, V>\n    } else if (key > current.key) {\n      current = current.right as Node<K, V>\n    } else {\n      // assuming value is an array here\n      // eslint-disable-next-line @typescript-eslint/no-extra-semi\n      ;(current.value as string[]) = (current.value as string[]).concat(value as string)\n      return root\n    }\n  }\n\n  const newNode = create(key, value)\n\n  if (!parent) {\n    root = newNode // tree was empty\n  } else if (key < parent.key) {\n    parent.left = newNode\n  } else {\n    parent.right = newNode\n  }\n\n  current = newNode\n\n  while (parent) {\n    const balanceFactor = getHeight(parent.left) - getHeight(parent.right)\n\n    if (balanceFactor === BALANCE_STATE.UNBALANCED_LEFT) {\n      if (key > (parent.left as Node<K, V>).key) {\n        parent.left = rotateLeft(parent.left as Node<K, V>)\n      }\n      parent = rotateRight(parent)\n    }\n\n    if (balanceFactor === BALANCE_STATE.UNBALANCED_RIGHT) {\n      if (key < (parent.right as Node<K, V>).key) {\n        parent.right = rotateRight(parent.right as Node<K, V>)\n      }\n      parent = rotateLeft(parent)\n    }\n\n    if (parent === root) {\n      break\n    }\n\n    current = parent\n    parent = getNodeParent(root, current.key)\n  }\n\n  return root\n}\n\nfunction getNodeParent<K, V>(root: Node<K, V>, key: K): Node<K, V> | null {\n  let current = root\n  let parent = null\n\n  while (current !== null) {\n    if (key < current.key) {\n      parent = current\n      current = current.left as Node<K, V>\n    } else if (key > current.key) {\n      parent = current\n      current = current.right as Node<K, V>\n    } else {\n      break\n    }\n  }\n\n  return parent\n}\n\nexport function find<K, V>(root: Node<K, V>, key: K): V | null {\n  const node = getNodeByKey(root, key)\n  if (!node) {\n    return null\n  }\n  return node.value\n}\n\nexport function remove<K, V>(root: Node<K, V> | null, key: K): Node<K, V> | null {\n  let node = root\n  let parentNode: Node<K, V> | null = null\n\n  while (node && node.key !== key) {\n    parentNode = node\n    if (key < node.key) {\n      node = node.left as Node<K, V>\n    } else {\n      node = node.right as Node<K, V>\n    }\n  }\n\n  if (!node) {\n    return null\n  }\n\n  if (!node.left && !node.right) {\n    if (!parentNode) {\n      // Node to be deleted is root\n      root = null\n    } else {\n      if (parentNode.left === node) {\n        parentNode.left = null\n      } else {\n        parentNode.right = null\n      }\n    }\n  } else if (node.left && node.right) {\n    let minValueNode = node.right\n    let minValueParent = node\n\n    while (minValueNode.left) {\n      minValueParent = minValueNode\n      minValueNode = minValueNode.left\n    }\n\n    node.key = minValueNode.key\n\n    if (minValueParent === node) {\n      minValueParent.right = minValueNode.right\n    } else {\n      minValueParent.left = minValueNode.right\n    }\n  } else {\n    const childNode = node.left ? node.left : node.right\n\n    if (!parentNode) {\n      root = childNode as Node<K, V>\n    } else {\n      if (parentNode.left === node) {\n        parentNode.left = childNode\n      } else {\n        parentNode.right = childNode\n      }\n    }\n  }\n\n  return root\n}\n\nexport function removeDocument<K, V>(root: Node<K, V[]>, id: V, key: K): void {\n  const node = getNodeByKey(root, key)!\n\n  if (node.value.length === 1) {\n    remove(root, key)\n    return\n  }\n\n  node.value.splice(node.value.indexOf(id), 1)\n}\n", "import { syncBoundedLevenshtein } from '../components/levenshtein.js'\nimport { InternalDocumentID } from '../components/internal-document-id-store.js'\nimport { getOwnProperty } from '../utils.js'\n\nexport class Node {\n  constructor(key: string, subWord: string, end: boolean) {\n    this.key = key\n    this.subWord = subWord\n    this.end = end\n  }\n\n  public key: string\n  public subWord: string\n  public children: Record<string, Node> = {}\n  public docs: InternalDocumentID[] = []\n  public end: boolean\n  public word = ''\n\n  public toJSON(): object {\n    return {\n      word: this.word,\n      subWord: this.subWord,\n      children: this.children,\n      docs: this.docs,\n      end: this.end,\n    }\n  }\n}\n\ntype FindParams = {\n  term: string\n  exact?: boolean\n  tolerance?: number\n}\n\ntype FindResult = Record<string, InternalDocumentID[]>\n\nfunction updateParent(node: Node, parent: Node): void {\n  node.word = parent.word + node.subWord\n}\n\nfunction addDocument(node: Node, docID: InternalDocumentID): void {\n  node.docs.push(docID)\n}\n\nfunction removeDocument(node: Node, docID: InternalDocumentID): boolean {\n  const index = node.docs.indexOf(docID)\n\n  /* c8 ignore next 3 */\n  if (index === -1) {\n    return false\n  }\n\n  node.docs.splice(index, 1)\n\n  return true\n}\n\nfunction findAllWords(node: Node, output: FindResult, term: string, exact?: boolean, tolerance?: number) {\n  if (node.end) {\n    const { word, docs: docIDs } = node\n\n    if (exact && word !== term) {\n      return {}\n    }\n\n    // always check in own property to prevent access to inherited properties\n    // fix https://github.com/OramaSearch/orama/issues/137\n    if (!getOwnProperty(output, word)) {\n      if (tolerance) {\n        // computing the absolute difference of letters between the term and the word\n        const difference = Math.abs(term.length - word.length)\n\n        // if the tolerance is set, check whether the edit distance is within tolerance.\n        // In that case, we don't need to add the word to the output\n        if (difference <= tolerance && syncBoundedLevenshtein(term, word, tolerance).isBounded) {\n          output[word] = []\n        }\n      } else {\n        // prevent default tolerance not set\n        output[word] = []\n      }\n    }\n\n    // check if _output[word] exists and then add the doc to it\n    // always check in own property to prevent access to inherited properties\n    // fix https://github.com/OramaSearch/orama/issues/137\n    if (getOwnProperty(output, word) && docIDs.length) {\n      const docs = new Set(output[word])\n\n      const docIDsLength = docIDs.length\n      for (let i = 0; i < docIDsLength; i++) {\n        docs.add(docIDs[i])\n      }\n      output[word] = Array.from(docs)\n    }\n  }\n\n  // recursively search the children\n  for (const character of Object.keys(node.children)) {\n    findAllWords(node.children[character], output, term, exact, tolerance)\n  }\n  return output\n}\n\nfunction getCommonPrefix(a: string, b: string) {\n  let commonPrefix = ''\n  const len = Math.min(a.length, b.length)\n  for (let i = 0; i < len; i++) {\n    if (a[i] !== b[i]) {\n      return commonPrefix\n    }\n    commonPrefix += a[i]\n  }\n  return commonPrefix\n}\n\nexport function create(end = false, subWord = '', key = ''): Node {\n  return new Node(key, subWord, end)\n}\n\nexport function insert(root: Node, word: string, docId: InternalDocumentID) {\n  for (let i = 0; i < word.length; i++) {\n    const currentCharacter = word[i]\n    const wordAtIndex = word.substring(i)\n    const rootChildCurrentChar = root.children[currentCharacter]\n\n    if (rootChildCurrentChar) {\n      const edgeLabel = rootChildCurrentChar.subWord\n      const edgeLabelLength = edgeLabel.length\n\n      const commonPrefix = getCommonPrefix(edgeLabel, wordAtIndex)\n      const commonPrefixLength = commonPrefix.length\n\n      // the wordAtIndex matches exactly with an existing child node\n      if (edgeLabel === wordAtIndex) {\n        addDocument(rootChildCurrentChar, docId)\n        rootChildCurrentChar.end = true\n        return\n      }\n\n      const edgeLabelAtCommonPrefix = edgeLabel[commonPrefixLength]\n      // the wordAtIndex is completely contained in the child node subword\n      if (commonPrefixLength < edgeLabelLength && commonPrefixLength === wordAtIndex.length) {\n        const newNode = create(true, wordAtIndex, currentCharacter) // Create a new node with end set to true\n        newNode.children[edgeLabelAtCommonPrefix] = rootChildCurrentChar\n\n        const newNodeChild = newNode.children[edgeLabelAtCommonPrefix]\n        newNodeChild.subWord = edgeLabel.substring(commonPrefixLength)\n        newNodeChild.key = edgeLabelAtCommonPrefix\n\n        root.children[currentCharacter] = newNode\n\n        updateParent(newNode, root)\n        updateParent(newNodeChild, newNode)\n        addDocument(newNode, docId)\n        return\n      }\n\n      // the wordAtIndex is partially contained in the child node subword\n      if (commonPrefixLength < edgeLabelLength && commonPrefixLength < wordAtIndex.length) {\n        const inbetweenNode = create(false, commonPrefix, currentCharacter)\n        inbetweenNode.children[edgeLabelAtCommonPrefix] = rootChildCurrentChar\n        root.children[currentCharacter] = inbetweenNode\n\n        const inbetweenNodeChild = inbetweenNode.children[edgeLabelAtCommonPrefix]\n        inbetweenNodeChild.subWord = edgeLabel.substring(commonPrefixLength)\n        inbetweenNodeChild.key = edgeLabelAtCommonPrefix\n\n        const wordAtCommonPrefix = wordAtIndex[commonPrefixLength]\n        const newNode = create(true, word.substring(i + commonPrefixLength), wordAtCommonPrefix)\n        addDocument(newNode, docId)\n\n        inbetweenNode.children[wordAtCommonPrefix] = newNode\n\n        updateParent(inbetweenNode, root)\n        updateParent(newNode, inbetweenNode)\n        updateParent(inbetweenNodeChild, inbetweenNode)\n        return\n      }\n\n      // skip to the next divergent character\n      i += edgeLabelLength - 1\n      // navigate in the child node\n      root = rootChildCurrentChar\n    } else {\n      // if the node for the current character doesn't exist create new node\n      const newNode = create(true, wordAtIndex, currentCharacter)\n      addDocument(newNode, docId)\n\n      root.children[currentCharacter] = newNode\n      updateParent(newNode, root)\n      return\n    }\n  }\n}\n\nexport function find(root: Node, { term, exact, tolerance }: FindParams): FindResult {\n  // find the closest node to the term\n  for (let i = 0; i < term.length; i++) {\n    const character = term[i]\n    if (character in root.children) {\n      const rootChildCurrentChar = root.children[character]\n      const edgeLabel = rootChildCurrentChar.subWord\n      const termSubstring = term.substring(i)\n\n      // find the common prefix between two words ex: prime and primate = prim\n      const commonPrefix = getCommonPrefix(edgeLabel, termSubstring)\n      const commonPrefixLength = commonPrefix.length\n      // if the common prefix length is equal to edgeLabel length (the node subword) it means they are a match\n      // if the common prefix is equal to the term means it is contained in the node\n      if (commonPrefixLength !== edgeLabel.length && commonPrefixLength !== termSubstring.length) {\n        // if tolerance is set we take the current node as the closest\n        if (tolerance) break\n        return {}\n      }\n\n      // skip the subword length and check the next divergent character\n      i += rootChildCurrentChar.subWord.length - 1\n      // navigate into the child node\n      root = rootChildCurrentChar\n    } else {\n      return {}\n    }\n  }\n\n  const output: FindResult = {}\n  // found the closest node we recursively search through children\n  findAllWords(root, output, term, exact, tolerance)\n\n  return output\n}\n\nexport function contains(root: Node, term: string): boolean {\n  for (let i = 0; i < term.length; i++) {\n    const character = term[i]\n\n    if (character in root.children) {\n      const rootChildrenChar = root.children[character]\n      const edgeLabel = rootChildrenChar.subWord\n      const termSubstring = term.substring(i)\n      const commonPrefix = getCommonPrefix(edgeLabel, termSubstring)\n      const commonPrefixLength = commonPrefix.length\n\n      if (commonPrefixLength !== edgeLabel.length && commonPrefixLength !== termSubstring.length) {\n        return false\n      }\n      i += rootChildrenChar.subWord.length - 1\n      root = rootChildrenChar\n    } else {\n      return false\n    }\n  }\n  return true\n}\n\nexport function removeWord(root: Node, term: string): boolean {\n  if (!term) {\n    return false\n  }\n\n  for (let i = 0; i < term.length; i++) {\n    const character = term[i]\n    const parent = root\n    if (character in root.children) {\n      i += root.children[character].subWord.length - 1\n      root = root.children[character]\n\n      if (Object.keys(root.children).length === 0) {\n        delete parent.children[root.key]\n        return true\n      }\n    } else {\n      return false\n    }\n  }\n\n  return false\n}\n\nexport function removeDocumentByWord(root: Node, term: string, docID: InternalDocumentID, exact = true): boolean {\n  if (!term) {\n    return true\n  }\n\n  for (let i = 0; i < term.length; i++) {\n    const character = term[i]\n    if (character in root.children) {\n      const rootChildCurrentChar = root.children[character]\n      i += rootChildCurrentChar.subWord.length - 1\n      root = rootChildCurrentChar\n\n      if (exact && root.word !== term) {\n        // Do nothing if the exact condition is not met.\n      } else {\n        removeDocument(root, docID)\n      }\n    } else {\n      return false\n    }\n  }\n  return true\n}\n", "export type BoundedMetric = {\n  isBounded: boolean\n  distance: number\n}\n\n/**\n * Inspired by:\n * https://github.com/Yomguithereal/talisman/blob/86ae55cbd040ff021d05e282e0e6c71f2dde21f8/src/metrics/levenshtein.js#L218-L340\n */\nfunction _boundedLevenshtein(a: string, b: string, tolerance: number): number {\n  // the strings are the same\n  if (a === b) {\n    return 0\n  }\n\n  // a should be the shortest string\n  const swap = a\n  if (a.length > b.length) {\n    a = b\n    b = swap\n  }\n\n  let lenA = a.length\n  let lenB = b.length\n\n  // ignore common suffix\n  // note: `~-` decreases by a unit in a bitwise fashion\n  while (lenA > 0 && a.charCodeAt(~-lenA) === b.charCodeAt(~-lenB)) {\n    lenA--\n    lenB--\n  }\n\n  // early return when the smallest string is empty\n  if (!lenA) {\n    return lenB > tolerance ? -1 : lenB\n  }\n\n  // ignore common prefix\n  let startIdx = 0\n  while (startIdx < lenA && a.charCodeAt(startIdx) === b.charCodeAt(startIdx)) {\n    startIdx++\n  }\n  lenA -= startIdx\n  lenB -= startIdx\n\n  // early return when the smallest string is empty\n  if (lenA === 0) {\n    return lenB > tolerance ? -1 : lenB\n  }\n\n  const delta = lenB - lenA\n\n  if (tolerance > lenB) {\n    tolerance = lenB\n  } else if (delta > tolerance) {\n    return -1\n  }\n\n  let i = 0\n  const row = []\n  const characterCodeCache = []\n\n  while (i < tolerance) {\n    characterCodeCache[i] = b.charCodeAt(startIdx + i)\n    row[i] = ++i\n  }\n\n  while (i < lenB) {\n    characterCodeCache[i] = b.charCodeAt(startIdx + i)\n    row[i++] = tolerance + 1\n  }\n\n  const offset = tolerance - delta\n  const haveMax = tolerance < lenB\n\n  let jStart = 0\n  let jEnd = tolerance\n\n  let current = 0\n  let left = 0\n  let above = 0\n  let charA = 0\n  let j = 0\n\n  // Starting the nested loops\n  for (i = 0; i < lenA; i++) {\n    left = i\n    current = i + 1\n\n    charA = a.charCodeAt(startIdx + i)\n    jStart += i > offset ? 1 : 0\n    jEnd += jEnd < lenB ? 1 : 0\n\n    for (j = jStart; j < jEnd; j++) {\n      above = current\n\n      current = left\n      left = row[j]\n\n      if (charA !== characterCodeCache[j]) {\n        // insert current\n        if (left < current) {\n          current = left\n        }\n\n        // delete current\n        if (above < current) {\n          current = above\n        }\n\n        current++\n      }\n\n      row[j] = current\n    }\n\n    if (haveMax && row[i + delta] > tolerance) {\n      return -1\n    }\n  }\n\n  return current <= tolerance ? current : -1\n}\n\n/**\n * Computes the Levenshtein distance between two strings (a, b), returning early with -1 if the distance\n * is greater than the given tolerance.\n * It assumes that:\n * - tolerance >= ||a| - |b|| >= 0\n */\nexport async function boundedLevenshtein(a: string, b: string, tolerance: number): Promise<BoundedMetric> {\n  const distance = _boundedLevenshtein(a, b, tolerance)\n  return {\n    distance,\n    isBounded: distance >= 0,\n  }\n}\n\n// This is only used internally, keep in sync with the previous one\nexport function syncBoundedLevenshtein(a: string, b: string, tolerance: number): BoundedMetric {\n  const distance = _boundedLevenshtein(a, b, tolerance)\n  return {\n    distance,\n    isBounded: distance >= 0,\n  }\n}\n\nexport function levenshtein(a: string, b: string): number {\n  /* c8 ignore next 3 */\n  if (!a.length) {\n    return b.length\n  }\n\n  /* c8 ignore next 3 */\n  if (!b.length) {\n    return a.length\n  }\n\n  const swap = a\n  if (a.length > b.length) {\n    a = b\n    b = swap\n  }\n\n  const row = Array.from({ length: a.length + 1 }, (_, i) => i)\n  let val = 0\n\n  for (let i = 1; i <= b.length; i++) {\n    let prev = i\n\n    for (let j = 1; j <= a.length; j++) {\n      if (b[i - 1] === a[j - 1]) {\n        val = row[j - 1]\n      } else {\n        val = Math.min(row[j - 1] + 1, Math.min(prev + 1, row[j] + 1))\n      }\n\n      row[j - 1] = prev\n      prev = val\n    }\n    row[a.length] = prev\n  }\n\n  return row[a.length]\n}\n", "import { createError } from '../errors.js'\nimport { TokenScore, BM25Params } from '../types.js'\nimport { InternalDocumentID } from './internal-document-id-store.js'\n\nexport function prioritizeTokenScores(\n  arrays: TokenScore[][],\n  boost: number,\n  threshold = 1,\n  keywordsCount: number,\n): TokenScore[] {\n  if (boost === 0) {\n    throw createError('INVALID_BOOST_VALUE')\n  }\n\n  const tokenScoresMap = new Map<InternalDocumentID, number>()\n  const tokenKeywordsCountMap = new Map<InternalDocumentID, number>()\n\n  const mapsLength = arrays.length\n  for (let i = 0; i < mapsLength; i++) {\n    const arr = arrays[i]\n\n    const entriesLength = arr.length\n    for (let j = 0; j < entriesLength; j++) {\n      const [token, score] = arr[j]\n      const boostScore = score * boost\n      const oldScore = tokenScoresMap.get(token)\n\n      if (oldScore !== undefined) {\n        tokenScoresMap.set(token, oldScore * 1.5 + boostScore)\n        tokenKeywordsCountMap.set(token, tokenKeywordsCountMap.get(token)! + 1)\n      } else {\n        tokenScoresMap.set(token, boostScore)\n        tokenKeywordsCountMap.set(token, 1)\n      }\n    }\n  }\n\n  const tokenScores: TokenScore[] = []\n\n  for (const tokenScoreEntry of tokenScoresMap.entries()) {\n    tokenScores.push(tokenScoreEntry)\n  }\n\n  const results = tokenScores.sort((a, b) => b[1] - a[1])\n\n  // If threshold is 1, it means we will return all the results with at least one search term,\n  // prioritizig the ones that contains more search terms (fuzzy match)\n  if (threshold === 1) {\n    return results\n  }\n\n  // Prepare keywords count tracking for threshold handling\n  const allResults = results.length\n  const tokenKeywordsCount: [InternalDocumentID, number][] = []\n\n  for (const tokenKeywordsCountEntry of tokenKeywordsCountMap.entries()) {\n    tokenKeywordsCount.push(tokenKeywordsCountEntry)\n  }\n\n  // Find the index of the last result with all keywords.\n  // Note that since score is multipled by 1.5 any time the token is encountered in results it means\n  // that tokenScores and tokenKeywordsCount should always have the same order.\n  const keywordsPerToken = tokenKeywordsCount.sort((a, b) => b[1] - a[1])\n\n  let lastTokenWithAllKeywords: number | undefined = undefined\n  for (let i = 0; i < allResults; i++) {\n    if (keywordsPerToken[i][1] === keywordsCount) {\n      lastTokenWithAllKeywords = i\n    } else {\n      break\n    }\n  }\n\n  // If no results had all the keywords, either bail out earlier or normalize\n  if (typeof lastTokenWithAllKeywords === 'undefined') {\n    if (threshold === 0) {\n      return []\n    }\n\n    lastTokenWithAllKeywords = 0\n  }\n\n  // If threshold is 0, it means we will only return all the results that contains ALL the search terms (exact match)\n  if (threshold === 0) {\n    return results.slice(0, lastTokenWithAllKeywords + 1)\n  }\n\n  // If the threshold is between 0 and 1, we will return all the results that contains at least the threshold of search terms\n  // For example, if threshold is 0.5, we will return all the results that contains at least 50% of the search terms\n  // (fuzzy match with a minimum threshold)\n  const thresholdLength =\n    lastTokenWithAllKeywords + Math.ceil((threshold * 100 * (results.length - lastTokenWithAllKeywords)) / 100)\n\n  return results.slice(0, results.length + thresholdLength)\n}\n\nexport function BM25(\n  tf: number,\n  matchingCount: number,\n  docsCount: number,\n  fieldLength: number,\n  averageFieldLength: number,\n  BM25Params: Required<BM25Params>,\n) {\n  const { k, b, d } = BM25Params\n  const idf = Math.log(1 + (docsCount - matchingCount + 0.5) / (matchingCount + 0.5))\n  return (idf * (d + tf * (k + 1))) / (tf + k * (1 - b + (b * fieldLength) / averageFieldLength))\n}\n", "import { createError } from '../../errors.js'\nimport { Stemmer, Tokenizer, DefaultTokenizerConfig } from '../../types.js'\nimport { replaceDiacritics } from './diacritics.js'\nimport { Language, SPLITTERS, SUPPORTED_LANGUAGES } from './languages.js'\nimport { stemmer as english } from './english-stemmer.js'\n\ninterface DefaultTokenizer extends Tokenizer {\n  language: Language\n  stemmer?: Stemmer\n  stemmerSkipProperties: Set<string>\n  stopWords?: string[]\n  allowDuplicates: boolean\n  normalizationCache: Map<string, string>\n  normalizeToken(this: DefaultTokenizer, token: string, prop: string | undefined): string\n}\n\nfunction normalizeToken(this: DefaultTokenizer, prop: string, token: string): string {\n  const key = `${this.language}:${prop}:${token}`\n\n  if (this.normalizationCache.has(key)) {\n    return this.normalizationCache.get(key)!\n  }\n\n  // Remove stopwords if enabled\n  if (this.stopWords?.includes(token)) {\n    this.normalizationCache.set(key, '')\n    return ''\n  }\n\n  // Apply stemming if enabled\n  if (this.stemmer && !this.stemmerSkipProperties.has(prop)) {\n    token = this.stemmer(token)\n  }\n\n  token = replaceDiacritics(token)\n  this.normalizationCache.set(key, token)\n  return token\n}\n\n/* c8 ignore next 10 */\nfunction trim(text: string[]): string[] {\n  while (text[text.length - 1] === '') {\n    text.pop()\n  }\n  while (text[0] === '') {\n    text.shift()\n  }\n  return text\n}\n\nfunction tokenize(this: DefaultTokenizer, input: string, language?: string, prop?: string): string[] {\n  if (language && language !== this.language) {\n    throw createError('LANGUAGE_NOT_SUPPORTED', language)\n  }\n\n  /* c8 ignore next 3 */\n  if (typeof input !== 'string') {\n    return [input]\n  }\n\n  const splitRule = SPLITTERS[this.language]\n  const tokens = input\n    .toLowerCase()\n    .split(splitRule)\n    .map(this.normalizeToken.bind(this, prop ?? ''))\n    .filter(Boolean)\n  const trimTokens = trim(tokens)\n\n  if (!this.allowDuplicates) {\n    return Array.from(new Set(trimTokens))\n  }\n\n  return trimTokens\n}\n\nexport async function createTokenizer(config: DefaultTokenizerConfig = {}): Promise<DefaultTokenizer> {\n  if (!config.language) {\n    config.language = 'english'\n  } else if (!SUPPORTED_LANGUAGES.includes(config.language)) {\n    throw createError('LANGUAGE_NOT_SUPPORTED', config.language)\n  }\n\n  // Handle stemming - It is disabled by default\n  let stemmer: Stemmer | undefined\n\n  if (config.stemming || (config.stemmer && !('stemming' in config))) {\n    if (config.stemmer) {\n      if (typeof config.stemmer !== 'function') {\n        throw createError('INVALID_STEMMER_FUNCTION_TYPE')\n      }\n\n      stemmer = config.stemmer\n    } else {\n      if (config.language === 'english') {\n        stemmer = english\n      } else {\n        throw createError('MISSING_STEMMER', config.language)\n      }\n    }\n  }\n\n  // Handle stopwords\n  let stopWords: string[] | undefined\n\n  if (config.stopWords !== false) {\n    stopWords = []\n\n    if (Array.isArray(config.stopWords)) {\n      stopWords = config.stopWords\n    } else if (typeof config.stopWords === 'function') {\n      stopWords = await config.stopWords(stopWords)\n    } else if (config.stopWords) {\n      throw createError('CUSTOM_STOP_WORDS_MUST_BE_FUNCTION_OR_ARRAY')\n    }\n\n    // Make sure stopWords is just an array of strings\n    if (!Array.isArray(stopWords)) {\n      throw createError('CUSTOM_STOP_WORDS_MUST_BE_FUNCTION_OR_ARRAY')\n    }\n\n    for (const s of stopWords) {\n      if (typeof s !== 'string') {\n        throw createError('CUSTOM_STOP_WORDS_MUST_BE_FUNCTION_OR_ARRAY')\n      }\n    }\n  }\n\n  // Create the tokenizer\n  const tokenizer: DefaultTokenizer = {\n    tokenize,\n    language: config.language,\n    stemmer,\n    stemmerSkipProperties: new Set(config.stemmerSkipProperties ? [config.stemmerSkipProperties].flat() : []),\n    stopWords,\n    allowDuplicates: Boolean(config.allowDuplicates),\n    normalizeToken,\n    normalizationCache: new Map(),\n  }\n\n  tokenizer.tokenize = tokenize.bind(tokenizer)\n  tokenizer.normalizeToken = normalizeToken\n\n  return tokenizer\n}\n", "const DIACRITICS_CHARCODE_START = 192\nconst DIACRITICS_CHARCODE_END = 383\n\nconst CHARCODE_REPLACE_MAPPING = [\n  65,\n  65,\n  65,\n  65,\n  65,\n  65,\n  65,\n  67,\n  69,\n  69,\n  69,\n  69,\n  73,\n  73,\n  73,\n  73,\n  69,\n  78,\n  79,\n  79,\n  79,\n  79,\n  79,\n  null,\n  79,\n  85,\n  85,\n  85,\n  85,\n  89,\n  80,\n  115,\n  97,\n  97,\n  97,\n  97,\n  97,\n  97,\n  97,\n  99,\n  101,\n  101,\n  101,\n  101,\n  105,\n  105,\n  105,\n  105,\n  101,\n  110,\n  111,\n  111,\n  111,\n  111,\n  111,\n  null,\n  111,\n  117,\n  117,\n  117,\n  117,\n  121,\n  112,\n  121,\n  65,\n  97,\n  65,\n  97,\n  65,\n  97,\n  67,\n  99,\n  67,\n  99,\n  67,\n  99,\n  67,\n  99,\n  68,\n  100,\n  68,\n  100,\n  69,\n  101,\n  69,\n  101,\n  69,\n  101,\n  69,\n  101,\n  69,\n  101,\n  71,\n  103,\n  71,\n  103,\n  71,\n  103,\n  71,\n  103,\n  72,\n  104,\n  72,\n  104,\n  73,\n  105,\n  73,\n  105,\n  73,\n  105,\n  73,\n  105,\n  73,\n  105,\n  73,\n  105,\n  74,\n  106,\n  75,\n  107,\n  107,\n  76,\n  108,\n  76,\n  108,\n  76,\n  108,\n  76,\n  108,\n  76,\n  108,\n  78,\n  110,\n  78,\n  110,\n  78,\n  110,\n  110,\n  78,\n  110,\n  79,\n  111,\n  79,\n  111,\n  79,\n  111,\n  79,\n  111,\n  82,\n  114,\n  82,\n  114,\n  82,\n  114,\n  83,\n  115,\n  83,\n  115,\n  83,\n  115,\n  83,\n  115,\n  84,\n  116,\n  84,\n  116,\n  84,\n  116,\n  85,\n  117,\n  85,\n  117,\n  85,\n  117,\n  85,\n  117,\n  85,\n  117,\n  85,\n  117,\n  87,\n  119,\n  89,\n  121,\n  89,\n  90,\n  122,\n  90,\n  122,\n  90,\n  122,\n  115,\n]\n\nfunction replaceChar(charCode: number): number {\n  if (charCode < DIACRITICS_CHARCODE_START || charCode > DIACRITICS_CHARCODE_END) return charCode\n\n  /* c8 ignore next  */\n  return CHARCODE_REPLACE_MAPPING[charCode - DIACRITICS_CHARCODE_START] || charCode\n}\n\nexport function replaceDiacritics(str: string): string {\n  const stringCharCode = []\n  for (let idx = 0; idx < str.length; idx++) {\n    stringCharCode[idx] = replaceChar(str.charCodeAt(idx))\n  }\n  return String.fromCharCode(...stringCharCode)\n}\n", "// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-nocheck\n\nconst step2List = {\n  ational: 'ate',\n  tional: 'tion',\n  enci: 'ence',\n  anci: 'ance',\n  izer: 'ize',\n  bli: 'ble',\n  alli: 'al',\n  entli: 'ent',\n  eli: 'e',\n  ousli: 'ous',\n  ization: 'ize',\n  ation: 'ate',\n  ator: 'ate',\n  alism: 'al',\n  iveness: 'ive',\n  fulness: 'ful',\n  ousness: 'ous',\n  aliti: 'al',\n  iviti: 'ive',\n  biliti: 'ble',\n  logi: 'log',\n}\n\nconst step3List = {\n  icate: 'ic',\n  ative: '',\n  alize: 'al',\n  iciti: 'ic',\n  ical: 'ic',\n  ful: '',\n  ness: '',\n}\n\n// Consonant\nconst c = '[^aeiou]'\n// Vowel\nconst v = '[aeiouy]'\n// Consonant sequence\nconst C = c + '[^aeiouy]*'\n// Vowel sequence\nconst V = v + '[aeiou]*'\n\n// [C]VC... is m>0\nconst mgr0 = '^(' + C + ')?' + V + C\n// [C]VC[V] is m=1\nconst meq1 = '^(' + C + ')?' + V + C + '(' + V + ')?$'\n// [C]VCVC... is m>1\nconst mgr1 = '^(' + C + ')?' + V + C + V + C\n// vowel in stem\nconst s_v = '^(' + C + ')?' + v\n\nexport function stemmer(w) {\n  let stem\n  let suffix\n  let re\n  let re2\n  let re3\n  let re4\n\n  if (w.length < 3) {\n    return w\n  }\n\n  const firstch = w.substring(0, 1)\n  if (firstch == 'y') {\n    w = firstch.toUpperCase() + w.substring(1)\n  }\n\n  re = /^(.+?)(ss|i)es$/\n  re2 = /^(.+?)([^s])s$/\n\n  if (re.test(w)) {\n    w = w.replace(re, '$1$2')\n  } else if (re2.test(w)) {\n    w = w.replace(re2, '$1$2')\n  }\n\n  re = /^(.+?)eed$/\n  re2 = /^(.+?)(ed|ing)$/\n  if (re.test(w)) {\n    const fp = re.exec(w)\n    re = new RegExp(mgr0)\n    if (re.test(fp[1])) {\n      re = /.$/\n      w = w.replace(re, '')\n    }\n  } else if (re2.test(w)) {\n    const fp = re2.exec(w)\n    stem = fp[1]\n    re2 = new RegExp(s_v)\n    if (re2.test(stem)) {\n      w = stem\n      re2 = /(at|bl|iz)$/\n      re3 = new RegExp('([^aeiouylsz])\\\\1$')\n      re4 = new RegExp('^' + C + v + '[^aeiouwxy]$')\n      if (re2.test(w)) {\n        w = w + 'e'\n      } else if (re3.test(w)) {\n        re = /.$/\n        w = w.replace(re, '')\n      } else if (re4.test(w)) {\n        w = w + 'e'\n      }\n    }\n  }\n\n  re = /^(.+?)y$/\n  if (re.test(w)) {\n    const fp = re.exec(w)\n    stem = fp?.[1]\n    re = new RegExp(s_v)\n    if (stem && re.test(stem)) {\n      w = stem + 'i'\n    }\n  }\n\n  re =\n    /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/\n  if (re.test(w)) {\n    const fp = re.exec(w)\n    stem = fp?.[1]\n    suffix = fp?.[2]\n    re = new RegExp(mgr0)\n    if (stem && re.test(stem)) {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      w = stem + step2List[suffix]\n    }\n  }\n\n  re = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/\n  if (re.test(w)) {\n    const fp = re.exec(w)\n    stem = fp?.[1]\n    suffix = fp?.[2]\n    re = new RegExp(mgr0)\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    if (stem && re.test(stem)) {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      w = stem + step3List[suffix]\n    }\n  }\n\n  re = /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/\n  re2 = /^(.+?)(s|t)(ion)$/\n  if (re.test(w)) {\n    const fp = re.exec(w)\n    stem = fp?.[1]\n    re = new RegExp(mgr1)\n    if (stem && re.test(stem)) {\n      w = stem\n    }\n  } else if (re2.test(w)) {\n    const fp = re2.exec(w)\n    stem = fp?.[1] ?? '' + fp?.[2] ?? ''\n    re2 = new RegExp(mgr1)\n    if (re2.test(stem)) {\n      w = stem\n    }\n  }\n\n  re = /^(.+?)e$/\n  if (re.test(w)) {\n    const fp = re.exec(w)\n    stem = fp?.[1]\n    re = new RegExp(mgr1)\n    re2 = new RegExp(meq1)\n    re3 = new RegExp('^' + C + v + '[^aeiouwxy]$')\n    if (stem && (re.test(stem) || (re2.test(stem) && !re3.test(stem)))) {\n      w = stem\n    }\n  }\n\n  re = /ll$/\n  re2 = new RegExp(mgr1)\n  if (re.test(w) && re2.test(w)) {\n    re = /.$/\n    w = w.replace(re, '')\n  }\n\n  if (firstch == 'y') {\n    w = firstch.toLowerCase() + w.substring(1)\n  }\n\n  return w\n}\n", "import { createError } from '../errors.js'\nimport { ISorter, OpaqueSorter, Orama, Schema, SorterConfig, SorterParams, SortType, SortValue } from '../types.js'\nimport {\n  DocumentID,\n  getInternalDocumentId,\n  InternalDocumentID,\n  InternalDocumentIDStore,\n} from './internal-document-id-store.js'\n\ninterface PropertySort<K> {\n  docs: Map<InternalDocumentID, number>\n  orderedDocs: [InternalDocumentID, K][]\n  orderedDocsToRemove: Map<InternalDocumentID, boolean>\n  type: SortType\n}\n\ntype SerializablePropertySort<K> = Omit<PropertySort<K>, 'orderedDocsToRemove' | 'docs'> & {\n  docs: Record<string, number>\n}\n\nexport interface Sorter extends OpaqueSorter {\n  sharedInternalDocumentStore: InternalDocumentIDStore\n  isSorted: boolean\n  language: string\n  enabled: boolean\n  sortableProperties: string[]\n  sortablePropertiesWithTypes: Record<string, SortType>\n  sorts: Record<string, PropertySort<number | string | boolean>>\n}\n\nexport type DefaultSorter = ISorter<Sorter>\n\nfunction innerCreate(\n  orama: Orama,\n  sharedInternalDocumentStore: InternalDocumentIDStore,\n  schema: Schema,\n  sortableDeniedProperties: string[],\n  prefix: string,\n): Sorter {\n  const sorter: Sorter = {\n    language: orama.tokenizer.language,\n    sharedInternalDocumentStore,\n    enabled: true,\n    isSorted: true,\n    sortableProperties: [],\n    sortablePropertiesWithTypes: {},\n    sorts: {},\n  }\n\n  for (const [prop, type] of Object.entries(schema)) {\n    const typeActualType = typeof type\n    const path = `${prefix}${prefix ? '.' : ''}${prop}`\n\n    if (sortableDeniedProperties.includes(path)) {\n      continue\n    }\n\n    if (typeActualType === 'object' && !Array.isArray(type)) {\n      // Nested\n      const ret = innerCreate(orama, sharedInternalDocumentStore, type as Schema, sortableDeniedProperties, path)\n      sorter.sortableProperties.push(...ret.sortableProperties)\n      sorter.sorts = {\n        ...sorter.sorts,\n        ...ret.sorts,\n      }\n      sorter.sortablePropertiesWithTypes = {\n        ...sorter.sortablePropertiesWithTypes,\n        ...ret.sortablePropertiesWithTypes,\n      }\n      continue\n    }\n\n    switch (type) {\n      case 'boolean':\n      case 'number':\n      case 'string':\n        sorter.sortableProperties.push(path)\n        sorter.sortablePropertiesWithTypes[path] = type\n        sorter.sorts[path] = {\n          docs: new Map(),\n          orderedDocsToRemove: new Map(),\n          orderedDocs: [],\n          type: type,\n        }\n        break\n      case 'boolean[]':\n      case 'number[]':\n      case 'string[]':\n        // We don't allow to sort by arrays\n        continue\n      default:\n        throw createError('INVALID_SORT_SCHEMA_TYPE', Array.isArray(type) ? 'array' : (type as unknown as string), path)\n    }\n  }\n\n  return sorter\n}\n\nasync function create(\n  orama: Orama,\n  sharedInternalDocumentStore: InternalDocumentIDStore,\n  schema: Schema,\n  config?: SorterConfig,\n): Promise<Sorter> {\n  const isSortEnabled = config?.enabled !== false\n  if (!isSortEnabled) {\n    return {\n      disabled: true,\n    } as unknown as Sorter\n  }\n  return innerCreate(orama, sharedInternalDocumentStore, schema, (config || {}).unsortableProperties || [], '')\n}\n\nasync function insert(sorter: Sorter, prop: string, id: DocumentID, value: SortValue): Promise<void> {\n  if (!sorter.enabled) {\n    return\n  }\n\n  sorter.isSorted = false\n\n  const internalId = getInternalDocumentId(sorter.sharedInternalDocumentStore, id)\n  const s = sorter.sorts[prop]\n\n  s.docs.set(internalId, s.orderedDocs.length)\n  s.orderedDocs.push([internalId, value])\n}\n\nfunction ensureIsSorted(sorter: Sorter): void {\n  if (sorter.isSorted) {\n    return\n  }\n\n  if (!sorter.enabled) {\n    return\n  }\n\n  const properties = Object.keys(sorter.sorts)\n  for (const prop of properties) {\n    ensurePropertyIsSorted(sorter, prop)\n  }\n\n  sorter.isSorted = true\n}\n\nfunction stringSort(\n  language: string | undefined,\n  value: [InternalDocumentID, SortValue],\n  d: [InternalDocumentID, SortValue],\n): number {\n  return (value[1] as string).localeCompare(d[1] as string, language)\n}\n\nfunction numberSort(value: [InternalDocumentID, SortValue], d: [InternalDocumentID, SortValue]): number {\n  return (value[1] as number) - (d[1] as number)\n}\n\nfunction booleanSort(value: [InternalDocumentID, SortValue], d: [InternalDocumentID, SortValue]): number {\n  return (d[1] as boolean) ? -1 : 1\n}\n\nfunction ensurePropertyIsSorted(sorter: Sorter, prop: string): void {\n  const s = sorter.sorts[prop]\n\n  let predicate: (value: [InternalDocumentID, SortValue], d: [InternalDocumentID, SortValue]) => number\n  switch (s.type) {\n    case 'string':\n      predicate = stringSort.bind(null, sorter.language)\n      break\n    case 'number':\n      predicate = numberSort.bind(null)\n      break\n    case 'boolean':\n      predicate = booleanSort.bind(null)\n      break\n  }\n\n  s.orderedDocs.sort(predicate)\n\n  // Increment position for the greather documents\n  const orderedDocsLength = s.orderedDocs.length\n  for (let i = 0; i < orderedDocsLength; i++) {\n    const docId = s.orderedDocs[i][0]\n    s.docs.set(docId, i)\n  }\n}\n\nfunction ensureOrderedDocsAreDeleted(sorter: Sorter): void {\n  const properties = Object.keys(sorter.sorts)\n  for (const prop of properties) {\n    ensureOrderedDocsAreDeletedByProperty(sorter, prop)\n  }\n}\n\nfunction ensureOrderedDocsAreDeletedByProperty(sorter: Sorter, prop: string): void {\n  const s = sorter.sorts[prop]\n\n  if (!s.orderedDocsToRemove.size) return\n\n  s.orderedDocs = s.orderedDocs.filter(doc => !s.orderedDocsToRemove.has(doc[0]))\n  s.orderedDocsToRemove.clear()\n}\n\nasync function remove(sorter: Sorter, prop: string, id: DocumentID) {\n  if (!sorter.enabled) {\n    return\n  }\n  const s = sorter.sorts[prop] as PropertySort<SortValue>\n  const internalId = getInternalDocumentId(sorter.sharedInternalDocumentStore, id)\n\n  const index = s.docs.get(internalId)\n\n  if (!index) return\n\n  s.docs.delete(internalId)\n  s.orderedDocsToRemove.set(internalId, true)\n}\n\nasync function sortBy(\n  sorter: Sorter,\n  docIds: [DocumentID, number][],\n  by: SorterParams,\n): Promise<[DocumentID, number][]> {\n  if (!sorter.enabled) {\n    throw createError('SORT_DISABLED')\n  }\n\n  const property = by.property\n  const isDesc = by.order === 'DESC'\n\n  const s = sorter.sorts[property]\n  if (!s) {\n    throw createError('UNABLE_TO_SORT_ON_UNKNOWN_FIELD', property, sorter.sortableProperties.join(', '))\n  }\n\n  ensureOrderedDocsAreDeletedByProperty(sorter, property)\n  ensureIsSorted(sorter)\n\n  docIds.sort((a, b) => {\n    // This sort algorithm works leveraging on\n    // that s.docs is a map of docId -> position\n    // If a document is not indexed, it will be not present in the map\n    const indexOfA = s.docs.get(getInternalDocumentId(sorter.sharedInternalDocumentStore, a[0]))\n    const indexOfB = s.docs.get(getInternalDocumentId(sorter.sharedInternalDocumentStore, b[0]))\n    const isAIndexed = typeof indexOfA !== 'undefined'\n    const isBIndexed = typeof indexOfB !== 'undefined'\n\n    if (!isAIndexed && !isBIndexed) {\n      return 0\n    }\n    // unindexed documents are always at the end\n    if (!isAIndexed) {\n      return 1\n    }\n    if (!isBIndexed) {\n      return -1\n    }\n\n    return isDesc ? indexOfB - indexOfA : indexOfA - indexOfB\n  })\n\n  return docIds\n}\n\nasync function getSortableProperties(sorter: Sorter): Promise<string[]> {\n  if (!sorter.enabled) {\n    return []\n  }\n\n  return sorter.sortableProperties\n}\n\nasync function getSortablePropertiesWithTypes(sorter: Sorter): Promise<Record<string, SortType>> {\n  if (!sorter.enabled) {\n    return {}\n  }\n\n  return sorter.sortablePropertiesWithTypes\n}\n\nexport async function load<R = unknown>(sharedInternalDocumentStore: InternalDocumentIDStore, raw: R): Promise<Sorter> {\n  const rawDocument = raw as Omit<Sorter, 'sorts'> & {\n    sorts: Record<string, SerializablePropertySort<string | number | boolean>>\n  }\n  if (!rawDocument.enabled) {\n    return {\n      enabled: false,\n    } as unknown as Sorter\n  }\n\n  const sorts = Object.keys(rawDocument.sorts).reduce((acc, prop) => {\n    const { docs, orderedDocs, type } = rawDocument.sorts[prop]\n\n    acc[prop] = {\n      docs: new Map(Object.entries(docs).map(([k, v]) => [+k, v])),\n      orderedDocsToRemove: new Map(),\n      orderedDocs,\n      type,\n    }\n\n    return acc\n  }, {} as Record<string, PropertySort<string | number | boolean>>)\n\n  return {\n    sharedInternalDocumentStore,\n    language: rawDocument.language,\n    sortableProperties: rawDocument.sortableProperties,\n    sortablePropertiesWithTypes: rawDocument.sortablePropertiesWithTypes,\n    sorts,\n    enabled: true,\n    isSorted: rawDocument.isSorted,\n  }\n}\n\nexport async function save<R = unknown>(sorter: Sorter): Promise<R> {\n  if (!sorter.enabled) {\n    return {\n      enabled: false,\n    } as unknown as R\n  }\n\n  ensureOrderedDocsAreDeleted(sorter)\n  ensureIsSorted(sorter)\n\n  const sorts = Object.keys(sorter.sorts).reduce((acc, prop) => {\n    const { docs, orderedDocs, type } = sorter.sorts[prop]\n\n    acc[prop] = {\n      docs: Object.fromEntries(docs.entries()),\n      orderedDocs,\n      type,\n    }\n\n    return acc\n  }, {} as Record<string, SerializablePropertySort<string | number | boolean>>)\n\n  return {\n    language: sorter.language,\n    sortableProperties: sorter.sortableProperties,\n    sortablePropertiesWithTypes: sorter.sortablePropertiesWithTypes,\n    sorts,\n    enabled: sorter.enabled,\n    isSorted: sorter.isSorted,\n  } as R\n}\n\nexport async function createSorter(): Promise<DefaultSorter> {\n  return {\n    create,\n    insert,\n    remove,\n    save,\n    load,\n    sortBy,\n    getSortableProperties,\n    getSortablePropertiesWithTypes,\n  }\n}\n", "import { formatElapsedTime, getDocumentIndexId, getDocumentProperties, validateSchema } from '../components/defaults.js'\nimport { createDocumentsStore } from '../components/documents-store.js'\nimport { OBJECT_COMPONENTS, FUNCTION_COMPONENTS, SINGLE_OR_ARRAY_COMPONENTS } from '../components/hooks.js'\nimport { createIndex } from '../components/index.js'\nimport { createTokenizer } from '../components/tokenizer/index.js'\nimport { createInternalDocumentIDStore } from '../components/internal-document-id-store.js'\nimport { createError } from '../errors.js'\nimport { uniqueId } from '../utils.js'\nimport {\n  ArrayCallbackComponents,\n  Components,\n  Orama,\n  Schema,\n  FunctionComponents,\n  SingleOrArrayCallbackComponents,\n  Tokenizer,\n  SorterConfig,\n  OpaqueIndex,\n  OpaqueDocumentStore,\n  OpaqueSorter,\n  ProvidedTypes,\n  AfterSearch,\n  SingleCallbackComponent,\n  MultipleCallbackComponent,\n  SingleOrArray,\n} from '../types.js'\nimport { createSorter } from '../components/sorter.js'\n\ninterface CreateArguments<P extends ProvidedTypes> {\n  schema: Schema\n  sort?: SorterConfig\n  language?: string\n  components?: Components<P>\n  id?: string\n}\n\nfunction validateComponents<P extends ProvidedTypes>(components: Components<P>) {\n  const defaultComponents = {\n    formatElapsedTime,\n    getDocumentIndexId,\n    getDocumentProperties,\n    validateSchema,\n  }\n\n  for (const rawKey of FUNCTION_COMPONENTS) {\n    const key = rawKey as keyof FunctionComponents\n\n    if (components[key]) {\n      if (typeof components[key] !== 'function') {\n        throw createError('COMPONENT_MUST_BE_FUNCTION', key)\n      }\n    } else {\n      // @ts-expect-error TSC is unable to resolve this\n      components[key] = defaultComponents[key]\n    }\n  }\n\n  for (const rawKey of SINGLE_OR_ARRAY_COMPONENTS) {\n    const key = rawKey as keyof ArrayCallbackComponents<P>\n\n    const component:\n      | SingleOrArray<AfterSearch<P>>\n      | SingleOrArray<SingleCallbackComponent<P>>\n      | SingleOrArray<MultipleCallbackComponent<P>>\n      | undefined = components[key]\n    if (!component) {\n      components[key] = []\n    } else if (!Array.isArray(components[key])) {\n      // @ts-expect-error TSC is unable to resolve this\n      components[key] = [components[key]]\n    }\n\n    for (const fn of components[key] as unknown as SingleOrArrayCallbackComponents<P>[]) {\n      if (typeof fn !== 'function') {\n        throw createError('COMPONENT_MUST_BE_FUNCTION_OR_ARRAY_FUNCTIONS', key)\n      }\n    }\n  }\n\n  for (const rawKey of Object.keys(components)) {\n    if (\n      !OBJECT_COMPONENTS.includes(rawKey) &&\n      !FUNCTION_COMPONENTS.includes(rawKey) &&\n      !SINGLE_OR_ARRAY_COMPONENTS.includes(rawKey)\n    ) {\n      throw createError('UNSUPPORTED_COMPONENT', rawKey)\n    }\n  }\n}\n\nexport async function create<P extends ProvidedTypes>({\n  schema,\n  sort,\n  language,\n  components,\n  id,\n}: CreateArguments<P>): Promise<Orama<P>> {\n  if (!components) {\n    components = {}\n  }\n\n  if (!id) {\n    id = await uniqueId()\n  }\n\n  let tokenizer = components.tokenizer as Tokenizer\n  let index: OpaqueIndex | undefined = components.index\n  let documentsStore: OpaqueDocumentStore | undefined = components.documentsStore\n  let sorter: OpaqueSorter | undefined = components.sorter\n\n  if (!tokenizer) {\n    // Use the default tokenizer\n    tokenizer = await createTokenizer({ language: language ?? 'english' })\n  } else if (!tokenizer.tokenize) {\n    // If there is no tokenizer function, we assume this is a TokenizerConfig\n    tokenizer = await createTokenizer(tokenizer)\n  }\n\n  if (components.tokenizer && language) {\n    // Accept language only if a tokenizer is not provided\n    throw createError('NO_LANGUAGE_WITH_CUSTOM_TOKENIZER')\n  }\n\n  const internalDocumentStore = createInternalDocumentIDStore()\n\n  index ||= await createIndex()\n  sorter ||= await createSorter()\n  documentsStore ||= await createDocumentsStore()\n\n  // Validate all other components\n  validateComponents(components)\n\n  // Assign only recognized components and hooks\n  const {\n    getDocumentProperties,\n    getDocumentIndexId,\n    validateSchema,\n    beforeInsert,\n    afterInsert,\n    beforeRemove,\n    afterRemove,\n    beforeUpdate,\n    afterUpdate,\n    afterSearch,\n    beforeMultipleInsert,\n    afterMultipleInsert,\n    beforeMultipleRemove,\n    afterMultipleRemove,\n    beforeMultipleUpdate,\n    afterMultipleUpdate,\n    formatElapsedTime,\n  } = components\n\n  const orama = {\n    data: {},\n    caches: {},\n    schema,\n    tokenizer,\n    index,\n    sorter,\n    documentsStore,\n    internalDocumentIDStore: internalDocumentStore,\n    getDocumentProperties,\n    getDocumentIndexId,\n    validateSchema,\n    beforeInsert,\n    afterInsert,\n    beforeRemove,\n    afterRemove,\n    beforeUpdate,\n    afterUpdate,\n    afterSearch,\n    beforeMultipleInsert,\n    afterMultipleInsert,\n    beforeMultipleRemove,\n    afterMultipleRemove,\n    beforeMultipleUpdate,\n    afterMultipleUpdate,\n    formatElapsedTime,\n    id,\n  } as Orama\n\n  orama.data = {\n    index: await orama.index.create(orama, internalDocumentStore, schema),\n    docs: await orama.documentsStore.create(orama, internalDocumentStore),\n    sorting: await orama.sorter.create(orama, internalDocumentStore, schema, sort),\n  }\n\n  return orama\n}\n", "import { Document, Orama } from '../types.js'\n\nexport function getByID(db: Orama, id: string): Promise<Document | undefined> {\n  return db.documentsStore.get(db.data.docs, id) as Promise<Document | undefined>\n}\n\nexport function count(db: Orama): Promise<number> {\n  return db.documentsStore.count(db.data.docs) as Promise<number>\n}\n", "export * from './components/defaults.js'\nexport * as documentsStore from './components/documents-store.js'\nexport * as index from './components/index.js'\nexport * as tokenizer from './components/tokenizer/index.js'\nexport * as sorter from './components/sorter.js'\nexport * as internalDocumentIDStore from './components/internal-document-id-store.js'\n", "import { Language } from './components/tokenizer/languages.js'\nimport { DocumentID, InternalDocumentID, InternalDocumentIDStore } from './components/internal-document-id-store.js'\n\nexport type Nullable<T> = T | null\n\nexport type SingleOrArray<T> = T | T[]\n\nexport type SyncOrAsyncValue<T = void> = T | Promise<T>\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface OpaqueIndex {}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface OpaqueDocumentStore {}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface OpaqueSorter {}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface Schema extends Record<string, SearchableType | Schema> {}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface Document extends Record<string, SearchableValue | Document | unknown> {}\n\nexport type ScalarSearchableType = 'string' | 'number' | 'boolean'\nexport type ArraySearchableType = 'string[]' | 'number[]' | 'boolean[]'\nexport type SearchableType = ScalarSearchableType | ArraySearchableType\n\nexport type ScalarSearchableValue = string | number | boolean\nexport type ArraySearchableValue = string[] | number[] | boolean[]\nexport type SearchableValue = ScalarSearchableValue | ArraySearchableValue\n\nexport type SortType = 'string' | 'number' | 'boolean'\nexport type SortValue = string | number | boolean\n\nexport type BM25Params = {\n  k?: number\n  b?: number\n  d?: number\n}\n\nexport type FacetSorting = 'asc' | 'desc' | 'ASC' | 'DESC'\n\nexport interface StringFacetDefinition {\n  limit?: number\n  offset?: number\n  sort?: FacetSorting\n}\n\nexport interface NumberFacetDefinition {\n  ranges: { from: number; to: number }[]\n}\n\nexport interface BooleanFacetDefinition {\n  true?: boolean\n  false?: boolean\n}\n\nexport type FacetsParams = Record<string, FacetDefinition>\n\nexport type FacetDefinition = StringFacetDefinition | NumberFacetDefinition | BooleanFacetDefinition\n\nexport type ReduceFunction<T, R extends Result = Result> = (\n  values: ScalarSearchableValue[],\n  acc: T,\n  value: R,\n  index: number,\n) => T\nexport type Reduce<T> = {\n  reducer: ReduceFunction<T>\n  getInitialValue: (elementCount: number) => T\n}\n\nexport type GroupByParams<T> = {\n  properties: string[]\n  maxResult?: number\n  reduce?: Reduce<T>\n}\n\nexport type ComparisonOperator = {\n  gt?: number\n  gte?: number\n  lt?: number\n  lte?: number\n  eq?: number\n  between?: [number, number]\n}\n\n/**\n * A custom sorter function item as [id, score, document].\n */\nexport type CustomSorterFunctionItem = [InternalDocumentID, number, Document]\n\nexport type CustomSorterFunction = (a: CustomSorterFunctionItem, b: CustomSorterFunctionItem) => number\n/**\n * Define which properties to sort for.\n */\nexport type SorterParams = {\n  /**\n   * The key of the document used to sort the result.\n   */\n  property: string\n  /**\n   * Whether to sort the result in ascending or descending order.\n   */\n  order?: 'ASC' | 'DESC'\n}\n\nexport type SortByParams = SorterParams | CustomSorterFunction\n\nexport type SearchParams<T = Result[]> = {\n  /**\n   * The word to search.\n   */\n  term?: string\n  /**\n   * The properties of the document to search in.\n   */\n  properties?: '*' | string[]\n  /**\n   * The number of matched documents to return.\n   */\n  limit?: number\n  /**\n   * The number of matched documents to skip.\n   */\n  offset?: number\n  /**\n   * The key of the document used to sort the result.\n   */\n  sortBy?: SortByParams\n  /**\n   * Whether to match the term exactly.\n   */\n  exact?: boolean\n  /**\n   * The maximum [levenshtein distance](https://en.wikipedia.org/wiki/Levenshtein_distance)\n   * between the term and the searchable property.\n   */\n  tolerance?: number\n  /**\n   * The BM25 parameters to use.\n   *\n   * k: Term frequency saturation parameter.\n   * The higher the value, the more important the term frequency becomes.\n   * The default value is 1.2. It should be set to a value between 1.2 and 2.0.\n   *\n   * b: Document length saturation impact. The higher the value, the more\n   * important the document length becomes. The default value is 0.75.\n   *\n   * d: Frequency normalization lower bound. Default value is 0.5.\n   *\n   * Full documentation: https://docs.oramasearch.com/usage/search/BM25-algorithm\n   *\n   * @see https://en.wikipedia.org/wiki/Okapi_BM25\n   */\n  relevance?: BM25Params\n  /**\n   * The boost to apply to the properties.\n   *\n   * The boost is a number that is multiplied to the score of the property.\n   * It can be used to give more importance to some properties.\n   *\n   * Full documentation: https://docs.oramasearch.com/usage/search/fields-boosting\n   *\n   * @example\n   * // Give more importance to the 'title' property.\n   * const result = await search(db, {\n   *  term: 'Michael',\n   *  properties: ['title', 'author'],\n   *  boost: {\n   *   title: 2\n   *  }\n   * });\n   *\n   * // In that case, the score of the 'title' property will be multiplied by 2.\n   */\n  boost?: Record<string, number>\n  /**\n   * Facets configuration\n   * Full documentation: https://docs.oramasearch.com/usage/search/facets\n   *\n   * A facet is a feature that allows users to narrow down their search results by specific\n   * attributes or characteristics, such as category, price, or location.\n   * This can help users find more relevant and specific results for their search query.\n   *\n   * @example\n   *\n   * const results = await search(db, {\n   *  term: 'Personal Computer',\n   *  properties: ['title', 'description', 'category.primary', 'category.secondary'],\n   *  facets: {\n   *    'category.primary': {\n   *      size: 10,\n   *      sort: 'ASC',\n   *    }\n   *  }\n   * });\n   */\n  facets?: FacetsParams\n\n  /**\n   * Distinct configuration\n   * Full documentation: https://docs.oramasearch.com/usage/search/introduction#distinct\n   *\n   * @example\n   * const results = await search(db, {\n   *  term: 'Headphones',\n   *  distinctOn: 'category.primary',\n   * })\n   */\n  distinctOn?: string\n\n  /**\n   * Groups configuration\n   * Full documentation: https://docs.oramasearch.com/usage/search/grouping\n   *\n   * @example\n   * const results = await search(db, {\n   *  term: 'Headphones',\n   *  groupBy: {\n   *   properties: ['category.primary'],\n   *   maxResult: 10,\n   *  }\n   * })\n   */\n  groupBy?: GroupByParams<T>\n\n  /**\n   * Filter the search results.\n   * Full documentation: https://docs.oramasearch.com/usage/search/filters\n   *\n   * @example\n   * // Search for documents that contain 'Headphones' in the 'description' and 'title' fields and\n   * // have a price less than 100.\n   *\n   * const result = await search(db, {\n   *  term: 'Headphones',\n   *  properties: ['description', 'title'],\n   *  where: {\n   *    price: {\n   *      lt: 100\n   *    }\n   *  }\n   * });\n   */\n  where?: Record<string, boolean | string | string[] | ComparisonOperator>\n\n  /**\n   * Threshold to use for refining the search results.\n   * The threshold is a number between 0 and 1 that represents the minimum score of the documents to return.\n   * By default, the threshold is 1.\n   *\n   * Full documentation: https://docs.oramasearch.com/usage/search/threshold\n   *\n   * @example\n   *\n   * const result = await search(db, {\n   *  term: 'Red Headphones'\n   *  threshold: 0\n   * });\n   *\n   * // The result will contain all the documents that contain both 'Red' and 'Headphones' in their properties.\n   *\n   * const result2 = await search(db, {\n   *  term: 'Red Headphones'\n   *  threshold: 1\n   * });\n   *\n   * // The result will contain all the documents that contain either 'Red' and 'Headphones' in their properties.\n   */\n  threshold?: number\n\n  /**\n   * Preflight query.\n   * Will return just the facets (if needed) and the number of matched documents for the given query.\n   *\n   * Full documentation: https://docs.oramasearch.com/usage/search/preflight\n   *\n   * @example\n   *\n   * const result = await search(db, {\n   *  term: 'Red Headphones',\n   *  preflight: true\n   * });\n   *\n   * console.log(result);\n   *\n   * // {\n   * //   elapsed: {\n   * //     raw: 181208,\n   * //     formatted: '181μs'\n   * //   },\n   * //   count: 100,\n   * // }\n   */\n  preflight?: boolean\n}\n\nexport type Result = {\n  /**\n   * The id of the document.\n   */\n  id: string\n  /**\n   * The score of the document in the search.\n   */\n  score: number\n  /**\n   * The document\n   */\n  document: Document\n}\n\nexport type FacetResult = Record<\n  string,\n  {\n    count: number\n    values: Record<string, number>\n  }\n>\n\nexport type GroupResult<T = Result[]> =\n  | {\n      values: ScalarSearchableValue[]\n      result: T\n    }[]\n\nexport type TokenScore = [InternalDocumentID, number]\n\nexport type TokenMap = Record<string, TokenScore[]>\n\nexport type IndexMap = Record<string, TokenMap>\n\nexport type SearchContext<I extends OpaqueIndex, D extends OpaqueDocumentStore, AggValue = Result[]> = {\n  timeStart: bigint\n  tokenizer: Tokenizer\n  index: IIndex<I>\n  documentsStore: IDocumentsStore<D>\n  language: string | undefined\n  params: SearchParams<AggValue>\n  docsCount: number\n  uniqueDocsIDs: Record<number, number>\n  indexMap: IndexMap\n  docsIntersection: TokenMap\n}\n\nexport type ElapsedTime = {\n  raw: number\n  formatted: string\n}\n\nexport type Results<AggValue = Result[]> = {\n  /**\n   * The number of all the matched documents.\n   */\n  count: number\n  /**\n   * An array of matched documents taking `limit` and `offset` into account.\n   */\n  hits: Result[]\n  /**\n   * The time taken to search.\n   */\n  elapsed: ElapsedTime\n  /**\n   * The facets results.\n   */\n  facets?: FacetResult\n\n  groups?: GroupResult<AggValue>\n}\n\nexport type SingleCallbackComponent<P extends ProvidedTypes> = (\n  orama: Orama<P>,\n  id: string,\n  doc?: Document,\n) => SyncOrAsyncValue\n\nexport type MultipleCallbackComponent<P extends ProvidedTypes> = (\n  orama: Orama<P>,\n  doc: Document[] | string[],\n) => SyncOrAsyncValue\n\nexport type AfterSearch<P extends ProvidedTypes> = <AggValue>(\n  db: Orama<P>,\n  params: SearchParams<AggValue>,\n  language: string | undefined,\n  results: Results<AggValue>,\n) => SyncOrAsyncValue\n\nexport type IIndexInsertOrRemoveHookFunction<I extends OpaqueIndex = OpaqueIndex, R = void> = (\n  index: I,\n  prop: string,\n  id: string,\n  value: SearchableValue,\n  type: SearchableType,\n  language: string | undefined,\n  tokenizer: Tokenizer,\n  docsCount: number,\n) => SyncOrAsyncValue<R>\n\nexport interface IIndex<I extends OpaqueIndex = OpaqueIndex> {\n  create<S extends Schema, D extends OpaqueDocumentStore, So extends OpaqueSorter>(\n    orama: Orama<{ Schema: S; Index: I; DocumentStore: D; Sorter: So }>,\n    sharedInternalDocumentStore: InternalDocumentIDStore,\n    schema: Schema,\n  ): SyncOrAsyncValue<I>\n\n  beforeInsert?: IIndexInsertOrRemoveHookFunction<I>\n  insert: (\n    implementation: IIndex<I>,\n    index: I,\n    prop: string,\n    id: DocumentID,\n    value: SearchableValue,\n    schemaType: SearchableType,\n    language: string | undefined,\n    tokenizer: Tokenizer,\n    docsCount: number,\n  ) => SyncOrAsyncValue\n  afterInsert?: IIndexInsertOrRemoveHookFunction<I>\n\n  beforeRemove?: IIndexInsertOrRemoveHookFunction<I>\n  remove: (\n    implementation: IIndex<I>,\n    index: I,\n    prop: string,\n    id: DocumentID,\n    value: SearchableValue,\n    schemaType: SearchableType,\n    language: string | undefined,\n    tokenizer: Tokenizer,\n    docsCount: number,\n  ) => SyncOrAsyncValue<boolean>\n  afterRemove?: IIndexInsertOrRemoveHookFunction<I>\n\n  insertDocumentScoreParameters(\n    index: I,\n    prop: string,\n    id: DocumentID,\n    tokens: string[],\n    docsCount: number,\n  ): SyncOrAsyncValue\n  insertTokenScoreParameters(index: I, prop: string, id: DocumentID, tokens: string[], token: string): SyncOrAsyncValue\n  removeDocumentScoreParameters(index: I, prop: string, id: DocumentID, docsCount: number): SyncOrAsyncValue\n  removeTokenScoreParameters(index: I, prop: string, token: string): SyncOrAsyncValue\n  calculateResultScores<D extends OpaqueDocumentStore, AggValue = Result[]>(\n    context: SearchContext<I, D, AggValue>,\n    index: I,\n    prop: string,\n    term: string,\n    ids: DocumentID[],\n  ): SyncOrAsyncValue<TokenScore[]>\n\n  search<D extends OpaqueDocumentStore, AggValue = Result[]>(\n    context: SearchContext<I, D, AggValue>,\n    index: I,\n    prop: string,\n    term: string,\n  ): SyncOrAsyncValue<TokenScore[]>\n  searchByWhereClause<D extends OpaqueDocumentStore, AggValue = Result[]>(\n    context: SearchContext<I, D, AggValue>,\n    index: I,\n    filters: Record<string, boolean | string | string[] | ComparisonOperator>,\n  ): SyncOrAsyncValue<InternalDocumentID[]>\n\n  getSearchableProperties(index: I): SyncOrAsyncValue<string[]>\n  getSearchablePropertiesWithTypes(index: I): SyncOrAsyncValue<Record<string, SearchableType>>\n\n  load<R = unknown>(sharedInternalDocumentStore: InternalDocumentIDStore, raw: R): SyncOrAsyncValue<I>\n  save<R = unknown>(index: I): SyncOrAsyncValue<R>\n}\n\nexport interface IDocumentsStore<D extends OpaqueDocumentStore = OpaqueDocumentStore> {\n  create<S extends Schema, I extends OpaqueIndex, So extends OpaqueSorter>(\n    orama: Orama<{ Schema: S; Index: I; DocumentStore: D; Sorter: So }>,\n    sharedInternalDocumentStore: InternalDocumentIDStore,\n  ): SyncOrAsyncValue<D>\n  get(store: D, id: DocumentID): SyncOrAsyncValue<Document | undefined>\n  getMultiple(store: D, ids: DocumentID[]): SyncOrAsyncValue<(Document | undefined)[]>\n  getAll(store: D): SyncOrAsyncValue<Record<InternalDocumentID, Document>>\n  store(store: D, id: DocumentID, doc: Document): SyncOrAsyncValue<boolean>\n  remove(store: D, id: DocumentID): SyncOrAsyncValue<boolean>\n  count(store: D): SyncOrAsyncValue<number>\n\n  load<R = unknown>(sharedInternalDocumentStore: InternalDocumentIDStore, raw: R): SyncOrAsyncValue<D>\n  save<R = unknown>(store: D): SyncOrAsyncValue<R>\n}\n\nexport interface SorterConfig {\n  enabled?: boolean\n  unsortableProperties?: string[]\n}\n\nexport interface ISorter<So extends OpaqueSorter = OpaqueSorter> {\n  create<S extends Schema, I extends OpaqueIndex, D extends OpaqueDocumentStore>(\n    orama: Orama<{ Schema: S; Index: I; DocumentStore: D; Sorter: So }>,\n    sharedInternalDocumentStore: InternalDocumentIDStore,\n    schema: Schema,\n    sorterConfig?: SorterConfig,\n  ): SyncOrAsyncValue<So>\n  insert: (\n    sorter: So,\n    prop: string,\n    id: DocumentID,\n    value: SortValue,\n    schemaType: SortType,\n    language: string | undefined,\n  ) => SyncOrAsyncValue\n  remove: (sorter: So, prop: string, id: DocumentID) => SyncOrAsyncValue\n\n  load<R = unknown>(sharedInternalDocumentStore: InternalDocumentIDStore, raw: R): SyncOrAsyncValue<So>\n  save<R = unknown>(sorter: So): SyncOrAsyncValue<R>\n\n  sortBy(sorter: So, docIds: [DocumentID, number][], by: SorterParams): Promise<[DocumentID, number][]>\n\n  getSortableProperties(sorter: So): SyncOrAsyncValue<string[]>\n  getSortablePropertiesWithTypes(sorter: So): SyncOrAsyncValue<Record<string, SortType>>\n}\n\nexport type Stemmer = (word: string) => string\n\nexport type DefaultTokenizerConfig = {\n  language?: Language\n  stemming?: boolean\n  stemmer?: Stemmer\n  stemmerSkipProperties?: string | string[]\n  stopWords?: boolean | string[] | ((stopWords: string[]) => string[] | Promise<string[]>)\n  allowDuplicates?: boolean\n}\n\nexport interface Tokenizer {\n  language: string\n  normalizationCache: Map<string, string>\n  tokenize: (raw: string, language?: string, prop?: string) => SyncOrAsyncValue<string[]>\n}\n\nexport interface ObjectComponents<I extends OpaqueIndex, D extends OpaqueDocumentStore, So extends OpaqueSorter> {\n  tokenizer: Tokenizer | DefaultTokenizerConfig\n  index: I\n  documentsStore: D\n  sorter: So\n}\n\nexport interface FunctionComponents<S extends Schema = Schema> {\n  validateSchema(doc: Document, schema: S): SyncOrAsyncValue<string | undefined>\n  getDocumentIndexId(doc: Document): SyncOrAsyncValue<string>\n  getDocumentProperties(doc: Document, paths: string[]): SyncOrAsyncValue<Record<string, string | number | boolean>>\n  formatElapsedTime(number: bigint): SyncOrAsyncValue<number | string | object | ElapsedTime>\n}\n\nexport interface SingleOrArrayCallbackComponents<P extends ProvidedTypes> {\n  beforeInsert: SingleOrArray<SingleCallbackComponent<P>>\n  afterInsert: SingleOrArray<SingleCallbackComponent<P>>\n  beforeRemove: SingleOrArray<SingleCallbackComponent<P>>\n  afterRemove: SingleOrArray<SingleCallbackComponent<P>>\n  beforeUpdate: SingleOrArray<SingleCallbackComponent<P>>\n  afterUpdate: SingleOrArray<SingleCallbackComponent<P>>\n  afterSearch: SingleOrArray<AfterSearch<P>>\n  beforeMultipleInsert: SingleOrArray<MultipleCallbackComponent<P>>\n  afterMultipleInsert: SingleOrArray<MultipleCallbackComponent<P>>\n  beforeMultipleRemove: SingleOrArray<MultipleCallbackComponent<P>>\n  afterMultipleRemove: SingleOrArray<MultipleCallbackComponent<P>>\n  beforeMultipleUpdate: SingleOrArray<MultipleCallbackComponent<P>>\n  afterMultipleUpdate: SingleOrArray<MultipleCallbackComponent<P>>\n}\n\nexport interface ArrayCallbackComponents<P extends ProvidedTypes> {\n  beforeInsert: SingleCallbackComponent<P>[]\n  afterInsert: SingleCallbackComponent<P>[]\n  beforeRemove: SingleCallbackComponent<P>[]\n  afterRemove: SingleCallbackComponent<P>[]\n  beforeUpdate: SingleCallbackComponent<P>[]\n  afterUpdate: SingleCallbackComponent<P>[]\n  afterSearch: AfterSearch<P>[]\n  beforeMultipleInsert: MultipleCallbackComponent<P>[]\n  afterMultipleInsert: MultipleCallbackComponent<P>[]\n  beforeMultipleRemove: MultipleCallbackComponent<P>[]\n  afterMultipleRemove: MultipleCallbackComponent<P>[]\n  beforeMultipleUpdate: MultipleCallbackComponent<P>[]\n  afterMultipleUpdate: MultipleCallbackComponent<P>[]\n}\n\nexport type Components<P extends ProvidedTypes> = Partial<\n  ObjectComponents<P['Index'], P['DocumentStore'], P['Sorter']> &\n    FunctionComponents &\n    SingleOrArrayCallbackComponents<P>\n>\n\nexport const kInsertions = Symbol('orama.insertions')\nexport const kRemovals = Symbol('orama.removals')\n\ninterface Data<I extends OpaqueIndex, D extends OpaqueDocumentStore, S extends OpaqueSorter> {\n  index: I\n  docs: D\n  sorting: S\n}\n\ntype Internals<P extends ProvidedTypes> = {\n  schema: P['Schema']\n  tokenizer: Tokenizer\n  index: IIndex<P['Index']>\n  documentsStore: IDocumentsStore<P['DocumentStore']>\n  sorter: ISorter<P['Sorter']>\n  data: Data<P['Index'], P['DocumentStore'], P['Sorter']>\n  internalDocumentIDStore: InternalDocumentIDStore\n  caches: Record<string, unknown>\n  [kInsertions]: number | undefined\n  [kRemovals]: number | undefined\n}\n\ntype OramaID = {\n  id: string\n}\n\nexport type ProvidedTypes = {\n  Schema: Schema\n  Index: OpaqueIndex\n  DocumentStore: OpaqueDocumentStore\n  Sorter: OpaqueSorter\n}\n\ntype RequiredInner<T extends Partial<ProvidedTypes>> = {\n  [Key in keyof ProvidedTypes]: Key extends keyof ProvidedTypes\n    ? ProvidedTypes[Key]\n    : Key extends keyof T\n    ? T[Key]\n    : never\n}\n\nexport type Orama<\n  P extends Partial<ProvidedTypes> = {\n    Schema: Schema\n    Index: OpaqueIndex\n    DocumentStore: OpaqueDocumentStore\n    Sorter: OpaqueSorter\n  },\n> = FunctionComponents & ArrayCallbackComponents<RequiredInner<P>> & Internals<RequiredInner<P>> & OramaID\n", "import { kInsertions, kRemovals, Orama } from '../types.js'\n\n// Web platforms don't have process. React-Native doesn't have process.emitWarning.\nconst warn =\n  globalThis.process?.emitWarning ??\n  function emitWarning(message: string, options: { code: string }) {\n    console.warn(`[WARNING] [${options.code}] ${message}`)\n  }\n\nexport function trackInsertion(orama: Orama): void {\n  if (typeof orama[kInsertions] !== 'number') {\n    queueMicrotask(() => {\n      orama[kInsertions] = undefined\n    })\n\n    orama[kInsertions] = 0\n  }\n\n  if (orama[kInsertions]! > 1000) {\n    warn(\n      \"Orama's insert operation is synchronous. Please avoid inserting a large number of document in a single operation in order not to block the main thread or, in alternative, please use insertMultiple.\",\n      { code: 'ORAMA0001' },\n    )\n\n    orama[kInsertions] = -1\n  } else if (orama[kInsertions] >= 0) {\n    orama[kInsertions]++\n  }\n}\n\nexport function trackRemoval(orama: Orama): void {\n  if (typeof orama[kRemovals] !== 'number') {\n    queueMicrotask(() => {\n      orama[kRemovals] = undefined\n    })\n\n    orama[kRemovals] = 0\n  }\n\n  if (orama[kRemovals]! > 1000) {\n    warn(\n      \"Orama's remove operation is synchronous. Please avoid removing a large number of document in a single operation in order not to block the main thread, in alternative, please use updateMultiple.\",\n      { code: 'ORAMA0002' },\n    )\n\n    orama[kRemovals] = -1\n  } else if (orama[kRemovals] >= 0) {\n    orama[kRemovals]++\n  }\n}\n", "import { isArrayType } from '../components.js'\nimport { runMultipleHook, runSingleHook } from '../components/hooks.js'\nimport { trackInsertion } from '../components/sync-blocking-checker.js'\nimport { createError } from '../errors.js'\nimport { Document, Orama, SortValue } from '../types.js'\n\nexport async function insert(orama: Orama, doc: Document, language?: string, skipHooks?: boolean): Promise<string> {\n  const errorProperty = await orama.validateSchema(doc, orama.schema)\n  if (errorProperty) {\n    throw createError('SCHEMA_VALIDATION_FAILURE', errorProperty)\n  }\n\n  return innerInsert(orama, doc, language, skipHooks)\n}\n\nasync function innerInsert(orama: Orama, doc: Document, language?: string, skipHooks?: boolean): Promise<string> {\n  const { index, docs } = orama.data\n\n  const id = await orama.getDocumentIndexId(doc)\n\n  if (typeof id !== 'string') {\n    throw createError('DOCUMENT_ID_MUST_BE_STRING', typeof id)\n  }\n\n  if (!(await orama.documentsStore.store(docs, id, doc))) {\n    throw createError('DOCUMENT_ALREADY_EXISTS', id)\n  }\n\n  const docsCount = await orama.documentsStore.count(docs)\n\n  if (!skipHooks) {\n    await runSingleHook(orama.beforeInsert, orama, id, doc)\n  }\n\n  const indexableProperties = await orama.index.getSearchableProperties(index)\n  const indexablePropertiesWithTypes = await orama.index.getSearchablePropertiesWithTypes(index)\n  const indexableValues = await orama.getDocumentProperties(doc, indexableProperties)\n\n  for (const [key, value] of Object.entries(indexableValues)) {\n    if (typeof value === 'undefined') {\n      continue\n    }\n\n    const actualType = typeof value\n    const expectedType = indexablePropertiesWithTypes[key]\n\n    if (isArrayType(expectedType) && Array.isArray(value)) {\n      continue\n    }\n\n    if (actualType !== expectedType) {\n      throw createError('INVALID_DOCUMENT_PROPERTY', key, expectedType, actualType)\n    }\n  }\n\n  for (const prop of indexableProperties) {\n    const value = indexableValues[prop]\n    if (typeof value === 'undefined') {\n      continue\n    }\n\n    const expectedType = indexablePropertiesWithTypes[prop]\n    await orama.index.beforeInsert?.(\n      orama.data.index,\n      prop,\n      id,\n      value,\n      expectedType,\n      language,\n      orama.tokenizer,\n      docsCount,\n    )\n    await orama.index.insert(\n      orama.index,\n      orama.data.index,\n      prop,\n      id,\n      value,\n      expectedType,\n      language,\n      orama.tokenizer,\n      docsCount,\n    )\n    await orama.index.afterInsert?.(\n      orama.data.index,\n      prop,\n      id,\n      value,\n      expectedType,\n      language,\n      orama.tokenizer,\n      docsCount,\n    )\n  }\n\n  const sortableProperties = await orama.sorter.getSortableProperties(orama.data.sorting)\n  const sortablePropertiesWithTypes = await orama.sorter.getSortablePropertiesWithTypes(orama.data.sorting)\n  const sortableValues = await orama.getDocumentProperties(doc, sortableProperties)\n  for (const prop of sortableProperties) {\n    const value = sortableValues[prop] as SortValue\n    if (typeof value === 'undefined') {\n      continue\n    }\n\n    const expectedType = sortablePropertiesWithTypes[prop]\n\n    await orama.sorter.insert(orama.data.sorting, prop, id, value, expectedType, language)\n  }\n\n  if (!skipHooks) {\n    await runSingleHook(orama.afterInsert, orama, id, doc)\n  }\n\n  trackInsertion(orama)\n\n  return id\n}\n\nexport async function insertMultiple(\n  orama: Orama,\n  docs: Document[],\n  batchSize?: number,\n  language?: string,\n  skipHooks?: boolean,\n): Promise<string[]> {\n  if (!skipHooks) {\n    await runMultipleHook(orama.beforeMultipleInsert, orama, docs)\n  }\n\n  // Validate all documents before the insertion\n  const docsLength = docs.length\n  for (let i = 0; i < docsLength; i++) {\n    const errorProperty = await orama.validateSchema(docs[i], orama.schema)\n    if (errorProperty) {\n      throw createError('SCHEMA_VALIDATION_FAILURE', errorProperty)\n    }\n  }\n\n  return innerInsertMultiple(orama, docs, batchSize, language, skipHooks)\n}\n\nexport async function innerInsertMultiple(\n  orama: Orama,\n  docs: Document[],\n  batchSize?: number,\n  language?: string,\n  skipHooks?: boolean,\n): Promise<string[]> {\n  if (!batchSize) {\n    batchSize = 1000\n  }\n\n  const ids: string[] = []\n  await new Promise<void>((resolve, reject) => {\n    let i = 0\n    async function _insertMultiple() {\n      const batch = docs.slice(i * batchSize!, (i + 1) * batchSize!)\n      i++\n\n      if (!batch.length) {\n        return resolve()\n      }\n\n      for (const doc of batch) {\n        try {\n          const id = await insert(orama, doc, language, skipHooks)\n          ids.push(id)\n        } catch (err) {\n          reject(err)\n        }\n      }\n\n      setTimeout(_insertMultiple, 0)\n    }\n\n    setTimeout(_insertMultiple, 0)\n  })\n\n  if (!skipHooks) {\n    await runMultipleHook(orama.afterMultipleInsert, orama, docs)\n  }\n\n  return ids\n}\n", "import { runMultipleHook, runSingleHook } from '../components/hooks.js'\nimport {\n  DocumentID,\n  getDocumentIdFromInternalId,\n  getInternalDocumentId,\n} from '../components/internal-document-id-store.js'\nimport { trackRemoval } from '../components/sync-blocking-checker.js'\nimport { Orama } from '../types.js'\n\nexport async function remove(orama: Orama, id: DocumentID, language?: string, skipHooks?: boolean): Promise<boolean> {\n  let result = true\n  const { index, docs } = orama.data\n\n  const doc = await orama.documentsStore.get(docs, id)\n  if (!doc) {\n    return false\n  }\n\n  const docId = getDocumentIdFromInternalId(\n    orama.internalDocumentIDStore,\n    getInternalDocumentId(orama.internalDocumentIDStore, id),\n  )\n  const docsCount = await orama.documentsStore.count(docs)\n\n  if (!skipHooks) {\n    await runSingleHook(orama.beforeRemove, orama, docId)\n  }\n\n  const indexableProperties = await orama.index.getSearchableProperties(index)\n  const indexablePropertiesWithTypes = await orama.index.getSearchablePropertiesWithTypes(index)\n  const values = await orama.getDocumentProperties(doc, indexableProperties)\n\n  for (const prop of indexableProperties) {\n    const value = values[prop]\n    // The document doesn't contain the key\n    if (typeof value === 'undefined') {\n      continue\n    }\n\n    const schemaType = indexablePropertiesWithTypes[prop]\n\n    await orama.index.beforeRemove?.(\n      orama.data.index,\n      prop,\n      docId,\n      value,\n      schemaType,\n      language,\n      orama.tokenizer,\n      docsCount,\n    )\n    if (\n      !(await orama.index.remove(\n        orama.index,\n        orama.data.index,\n        prop,\n        id,\n        value,\n        schemaType,\n        language,\n        orama.tokenizer,\n        docsCount,\n      ))\n    ) {\n      result = false\n    }\n    await orama.index.afterRemove?.(\n      orama.data.index,\n      prop,\n      docId,\n      value,\n      schemaType,\n      language,\n      orama.tokenizer,\n      docsCount,\n    )\n  }\n\n  const sortableProperties = await orama.sorter.getSortableProperties(orama.data.sorting)\n  const sortableValues = await orama.getDocumentProperties(doc, sortableProperties)\n  for (const prop of sortableProperties) {\n    // The document doesn't contain the key\n    if (typeof sortableValues[prop] === 'undefined') {\n      continue\n    }\n\n    await orama.sorter.remove(orama.data.sorting, prop, id)\n  }\n\n  if (!skipHooks) {\n    await runSingleHook(orama.afterRemove, orama, docId)\n  }\n\n  await orama.documentsStore.remove(orama.data.docs, id)\n\n  trackRemoval(orama)\n  return result\n}\n\nexport async function removeMultiple(\n  orama: Orama,\n  ids: DocumentID[],\n  batchSize?: number,\n  language?: string,\n  skipHooks?: boolean,\n): Promise<number> {\n  let result = 0\n\n  if (!batchSize) {\n    batchSize = 1000\n  }\n\n  const docIdsForHooks = skipHooks\n    ? []\n    : ids.map(id =>\n        getDocumentIdFromInternalId(\n          orama.internalDocumentIDStore,\n          getInternalDocumentId(orama.internalDocumentIDStore, id),\n        ),\n      )\n\n  if (!skipHooks) {\n    await runMultipleHook(orama.beforeMultipleRemove, orama, docIdsForHooks)\n  }\n\n  await new Promise<void>((resolve, reject) => {\n    let i = 0\n    async function _insertMultiple() {\n      const batch = ids.slice(i * batchSize!, (i + 1) * batchSize!)\n      i++\n\n      if (!batch.length) {\n        return resolve()\n      }\n\n      for (const doc of batch) {\n        try {\n          if (await remove(orama, doc, language, skipHooks)) {\n            result++\n          }\n        } catch (err) {\n          reject(err)\n        }\n      }\n\n      setTimeout(_insertMultiple, 0)\n    }\n\n    setTimeout(_insertMultiple, 0)\n  })\n\n  if (!skipHooks) {\n    await runMultipleHook(orama.afterMultipleRemove, orama, docIdsForHooks)\n  }\n\n  return result\n}\n", "import type {\n  FacetResult,\n  FacetSorting,\n  FacetsParams,\n  NumberFacetDefinition,\n  Orama,\n  Schema,\n  SearchableValue,\n  StringFacetDefinition,\n  TokenScore,\n} from '../types.js'\nimport { getNested } from '../utils.js'\n\nfunction sortingPredicate(order: FacetSorting = 'desc', a: [string, number], b: [string, number]) {\n  if (order.toLowerCase() === 'asc') {\n    return a[1] - b[1]\n  } else {\n    return b[1] - a[1]\n  }\n}\n\nexport async function getFacets<S extends Schema>(\n  orama: Orama<{ Schema: S }>,\n  results: TokenScore[],\n  facetsConfig: FacetsParams,\n): Promise<FacetResult> {\n  const facets: FacetResult = {}\n  const allIDs = results.map(([id]) => id)\n  const allDocs = await orama.documentsStore.getMultiple(orama.data.docs, allIDs)\n  const facetKeys = Object.keys(facetsConfig!)\n\n  const properties = await orama.index.getSearchablePropertiesWithTypes(orama.data.index)\n\n  for (const facet of facetKeys) {\n    let values = {}\n\n    // Hack to guarantee the same order of ranges as specified by the user\n    // TODO: Revisit this once components land\n    if (properties[facet] === 'number') {\n      const { ranges } = facetsConfig[facet] as NumberFacetDefinition\n      const tmp = []\n      for (const range of ranges) {\n        tmp.push([`${range.from}-${range.to}`, 0])\n      }\n      values = Object.fromEntries(tmp)\n    }\n\n    facets[facet] = {\n      count: 0,\n      values,\n    }\n  }\n\n  const allDocsLength = allDocs.length\n  for (let i = 0; i < allDocsLength; i++) {\n    const doc = allDocs[i]\n\n    for (const facet of facetKeys) {\n      const facetValue = facet.includes('.')\n        ? (await getNested<string>(doc!, facet))!\n        : (doc![facet] as SearchableValue)\n\n      const propertyType = properties[facet]\n      switch (propertyType) {\n        case 'number': {\n          const ranges = (facetsConfig[facet] as NumberFacetDefinition).ranges\n          calculateNumberFacet(ranges, facets[facet].values, facetValue as number)\n          break\n        }\n        case 'number[]': {\n          const alreadyInsertedValues = new Set<string>()\n          const ranges = (facetsConfig[facet] as NumberFacetDefinition).ranges\n          for (const v of facetValue as Array<number>) {\n            calculateNumberFacet(ranges, facets[facet].values, v, alreadyInsertedValues)\n          }\n          break\n        }\n        case 'boolean':\n        case 'string': {\n          calculateBooleanOrStringFacet(facets[facet].values, facetValue as string | boolean, propertyType)\n          break\n        }\n        case 'boolean[]':\n        case 'string[]': {\n          const alreadyInsertedValues = new Set<string>()\n          const innerType = propertyType === 'boolean[]' ? 'boolean' : 'string'\n          for (const v of facetValue as Array<string | boolean>) {\n            calculateBooleanOrStringFacet(facets[facet].values, v, innerType, alreadyInsertedValues)\n          }\n          break\n        }\n      }\n    }\n  }\n\n  for (const facet of facetKeys) {\n    // Count the number of values for each facet\n    facets[facet].count = Object.keys(facets[facet].values).length\n\n    // Sort only string-based facets\n    if (properties[facet] === 'string') {\n      const stringFacetDefinition = facetsConfig as StringFacetDefinition\n\n      facets[facet].values = Object.fromEntries(\n        Object.entries(facets[facet].values)\n          .sort((a, b) => sortingPredicate(stringFacetDefinition.sort, a, b))\n          .slice(stringFacetDefinition.offset ?? 0, stringFacetDefinition.limit ?? 10),\n      )\n    }\n  }\n\n  return facets\n}\n\nfunction calculateNumberFacet(\n  ranges: NumberFacetDefinition['ranges'],\n  values: Record<string, number>,\n  facetValue: number,\n  alreadyInsertedValues?: Set<string>,\n) {\n  for (const range of ranges) {\n    const value = `${range.from}-${range.to}`\n    if (alreadyInsertedValues && alreadyInsertedValues.has(value)) {\n      continue\n    }\n\n    if (facetValue >= range.from && facetValue <= range.to) {\n      if (values[value] === undefined) {\n        values[value] = 1\n      } else {\n        values[value]++\n\n        if (alreadyInsertedValues) {\n          alreadyInsertedValues.add(value)\n        }\n      }\n    }\n  }\n}\n\nfunction calculateBooleanOrStringFacet(\n  values: Record<string, number>,\n  facetValue: string | boolean,\n  propertyType: 'string' | 'boolean',\n  alreadyInsertedValues?: Set<string>,\n) {\n  // String or boolean based facets\n  const value = facetValue?.toString() ?? (propertyType === 'boolean' ? 'false' : '')\n  if (alreadyInsertedValues && alreadyInsertedValues.has(value)) {\n    return\n  }\n  values[value] = (values[value] ?? 0) + 1\n  if (alreadyInsertedValues) {\n    alreadyInsertedValues.add(value)\n  }\n}\n", "import { InternalDocumentID } from './internal-document-id-store.js'\n\nexport function intersectFilteredIDs(\n  filtered: InternalDocumentID[],\n  lookedUp: [InternalDocumentID, number][],\n): [InternalDocumentID, number][] {\n  const map = new Map<number, boolean>()\n  const result: [number, number][] = []\n\n  for (const id of filtered) {\n    map.set(id, true)\n  }\n\n  for (const [id, score] of lookedUp) {\n    if (map.has(id)) {\n      result.push([id, score])\n      map.delete(id)\n    }\n  }\n\n  return result\n}\n", "import type { Orama, ScalarSearchableValue, TokenScore, GroupByParams, GroupResult, Result, Reduce } from '../types.js'\nimport { createError } from '../errors.js'\nimport { getNested, intersect } from '../utils.js'\nimport { getDocumentIdFromInternalId } from './internal-document-id-store.js'\n\ninterface PropertyGroup {\n  property: string\n  perValue: Record<\n    string,\n    {\n      indexes: number[]\n      count: number\n    }\n  >\n}\n\ninterface Group {\n  values: ScalarSearchableValue[]\n  indexes: number[]\n}\n\nconst DEFAULT_REDUCE: Reduce<Result[]> = {\n  reducer: (_, acc, res, index) => {\n    acc[index] = res\n    return acc\n  },\n  getInitialValue: length => Array.from({ length }),\n}\n\nconst ALLOWED_TYPES = ['string', 'number', 'boolean']\n\nexport async function getGroups<AggValue>(\n  orama: Orama,\n  results: TokenScore[],\n  groupBy: GroupByParams<AggValue>,\n): Promise<GroupResult<AggValue>> {\n  const properties = groupBy.properties\n  const propertiesLength = properties.length\n\n  const schemaProperties = await orama.index.getSearchablePropertiesWithTypes(orama.data.index)\n  for (let i = 0; i < propertiesLength; i++) {\n    const property = properties[i]\n    if (typeof schemaProperties[property] === 'undefined') {\n      throw createError('UNKNOWN_GROUP_BY_PROPERTY', property)\n    }\n    if (!ALLOWED_TYPES.includes(schemaProperties[property])) {\n      throw createError('INVALID_GROUP_BY_PROPERTY', property, ALLOWED_TYPES.join(', '), schemaProperties[property])\n    }\n  }\n\n  const allIDs = results.map(([id]) => getDocumentIdFromInternalId(orama.internalDocumentIDStore, id))\n\n  // allDocs is already sorted by the sortBy algorithm\n  // We leverage on that to limit the number of documents returned\n  const allDocs = await orama.documentsStore.getMultiple(orama.data.docs, allIDs)\n  const allDocsLength = allDocs.length\n\n  const returnedCount = groupBy.maxResult || Number.MAX_SAFE_INTEGER\n\n  const listOfValues: ScalarSearchableValue[][] = []\n\n  // We want to understand which documents have which values\n  // and group them by the property and values\n  const g: Record<string, PropertyGroup> = {}\n  for (let i = 0; i < propertiesLength; i++) {\n    const groupByKey = properties[i]\n    const group: PropertyGroup = {\n      property: groupByKey,\n      perValue: {},\n    }\n\n    const values: Set<ScalarSearchableValue> = new Set()\n    for (let j = 0; j < allDocsLength; j++) {\n      const doc = allDocs[j]\n\n      const value = await getNested<ScalarSearchableValue>(doc as object, groupByKey)\n      // we don't want to consider undefined values\n      if (typeof value === 'undefined') {\n        continue\n      }\n      const keyValue = typeof value !== 'boolean' ? value : '' + value\n      if (typeof group.perValue[keyValue] === 'undefined') {\n        group.perValue[keyValue] = {\n          indexes: [],\n          count: 0,\n        }\n      }\n      if (group.perValue[keyValue].count >= returnedCount) {\n        // We stop early because for this value we react the limit\n        continue\n      }\n\n      // We use the index to keep track of the original order\n      group.perValue[keyValue].indexes.push(j)\n      group.perValue[keyValue].count++\n\n      values.add(value)\n    }\n\n    listOfValues.push(Array.from(values))\n\n    g[groupByKey] = group\n  }\n\n  const combinations = calculateCombination(listOfValues)\n  const combinationsLength = combinations.length\n\n  const groups: Group[] = []\n  for (let i = 0; i < combinationsLength; i++) {\n    const combination = combinations[i]\n    const combinationLength = combination.length\n\n    const group: Group = {\n      values: [],\n      indexes: [],\n    }\n    const indexes: number[][] = []\n    for (let j = 0; j < combinationLength; j++) {\n      const value = combination[j]\n      const property = properties[j]\n      indexes.push(g[property].perValue[typeof value !== 'boolean' ? value : '' + value].indexes)\n      group.values.push(value)\n    }\n    // We leverage on the index to sort the results by the original order\n    group.indexes = intersect(indexes).sort((a, b) => a - b)\n\n    // don't generate empty groups\n    if (group.indexes.length === 0) {\n      continue\n    }\n\n    groups.push(group)\n  }\n\n  const groupsLength = groups.length\n  const res: GroupResult<AggValue> = Array.from({ length: groupsLength })\n  for (let i = 0; i < groupsLength; i++) {\n    const group = groups[i]\n\n    const reduce = (groupBy.reduce || DEFAULT_REDUCE) as Reduce<AggValue>\n\n    const docs = group.indexes.map(index => {\n      return {\n        id: allIDs[index],\n        score: results[index][1],\n        document: allDocs[index]!,\n      }\n    })\n\n    const func = reduce.reducer.bind(null, group.values)\n    const initialValue = reduce.getInitialValue(group.indexes.length)\n    const aggregationValue = docs.reduce(func, initialValue)\n\n    res[i] = {\n      values: group.values,\n      result: aggregationValue,\n    }\n  }\n\n  return res\n}\n\nfunction calculateCombination(arrs: ScalarSearchableValue[][], index = 0): ScalarSearchableValue[][] {\n  if (index + 1 === arrs.length) return arrs[index].map(item => [item])\n\n  const head = arrs[index]\n  const c = calculateCombination(arrs, index + 1)\n\n  const combinations = []\n  for (const value of head) {\n    for (const combination of c) {\n      combinations.push([value, ...combination])\n    }\n  }\n\n  return combinations\n}\n", "import { prioritizeTokenScores } from '../components/algorithms.js'\nimport { getFacets } from '../components/facets.js'\nimport { intersectFilteredIDs } from '../components/filters.js'\nimport { getGroups } from '../components/groups.js'\nimport { runAfterSearch } from '../components/hooks.js'\nimport {\n  getDocumentIdFromInternalId,\n  getInternalDocumentId,\n  InternalDocumentID,\n} from '../components/internal-document-id-store.js'\nimport { createError } from '../errors.js'\nimport {\n  BM25Params,\n  IndexMap,\n  Orama,\n  Result,\n  Results,\n  SearchContext,\n  SearchParams,\n  TokenMap,\n  ElapsedTime,\n  IIndex,\n  Tokenizer,\n  IDocumentsStore,\n  CustomSorterFunctionItem,\n  OpaqueIndex,\n  OpaqueDocumentStore,\n  SearchableValue,\n  TokenScore,\n} from '../types.js'\nimport { getNanosecondsTime, getNested, sortTokenScorePredicate } from '../utils.js'\n\nconst defaultBM25Params: BM25Params = {\n  k: 1.2,\n  b: 0.75,\n  d: 0.5,\n}\n\nasync function createSearchContext<I extends OpaqueIndex, D extends OpaqueDocumentStore, AggValue>(\n  tokenizer: Tokenizer,\n  index: IIndex<I>,\n  documentsStore: IDocumentsStore<D>,\n  language: string | undefined,\n  params: SearchParams<AggValue>,\n  properties: string[],\n  tokens: string[],\n  docsCount: number,\n  timeStart: bigint,\n): Promise<SearchContext<I, D, AggValue>> {\n  // If filters are enabled, we need to get the IDs of the documents that match the filters.\n  // const hasFilters = Object.keys(params.where ?? {}).length > 0;\n  // let whereFiltersIDs: string[] = [];\n\n  // if (hasFilters) {\n  //   whereFiltersIDs = getWhereFiltersIDs(params.where!, orama);\n  // }\n\n  // indexMap is an object containing all the indexes considered for the current search,\n  // and an array of doc IDs for each token in all the indices.\n  //\n  // Given the search term \"quick brown fox\" on the \"description\" index,\n  // indexMap will look like this:\n  //\n  // {\n  //   description: {\n  //     quick: [doc1, doc2, doc3],\n  //     brown: [doc2, doc4],\n  //     fox:   [doc2]\n  //   }\n  // }\n  const indexMap: IndexMap = {}\n\n  // After we create the indexMap, we need to calculate the intersection\n  // between all the postings lists for each token.\n  // Given the example above, docsIntersection will look like this:\n  //\n  // {\n  //   description: [doc2]\n  // }\n  //\n  // as doc2 is the only document present in all the postings lists for the \"description\" index.\n  const docsIntersection: TokenMap = {}\n\n  for (const prop of properties) {\n    const tokensMap: TokenMap = {}\n    for (const token of tokens) {\n      tokensMap[token] = []\n    }\n    indexMap[prop] = tokensMap\n    docsIntersection[prop] = []\n  }\n\n  return {\n    timeStart,\n    tokenizer,\n    index,\n    documentsStore,\n    language,\n    params,\n    docsCount,\n    uniqueDocsIDs: {},\n    indexMap,\n    docsIntersection,\n  }\n}\n\nexport async function search<AggValue = Result[]>(\n  orama: Orama,\n  params: SearchParams<AggValue>,\n  language?: string,\n): Promise<Results<AggValue>> {\n  const timeStart = await getNanosecondsTime()\n\n  params.relevance = Object.assign(params.relevance ?? {}, defaultBM25Params)\n\n  const shouldCalculateFacets = params.facets && Object.keys(params.facets).length > 0\n  const { limit = 10, offset = 0, term, properties, threshold = 1, distinctOn } = params\n  const isPreflight = params.preflight === true\n\n  const { index, docs } = orama.data\n  const tokens = await orama.tokenizer.tokenize(term ?? '', language)\n\n  // Get searchable string properties\n  let propertiesToSearch = orama.caches['propertiesToSearch'] as string[]\n  if (!propertiesToSearch) {\n    const propertiesToSearchWithTypes = await orama.index.getSearchablePropertiesWithTypes(index)\n\n    propertiesToSearch = await orama.index.getSearchableProperties(index)\n    propertiesToSearch = propertiesToSearch.filter((prop: string) =>\n      propertiesToSearchWithTypes[prop].startsWith('string'),\n    )\n\n    orama.caches['propertiesToSearch'] = propertiesToSearch\n  }\n\n  if (properties && properties !== '*') {\n    for (const prop of properties) {\n      if (!propertiesToSearch.includes(prop)) {\n        throw createError('UNKNOWN_INDEX', prop, propertiesToSearch.join(', '))\n      }\n    }\n\n    propertiesToSearch = propertiesToSearch.filter((prop: string) => properties.includes(prop))\n  }\n\n  // Create the search context and the results\n  const context = await createSearchContext(\n    orama.tokenizer,\n    orama.index,\n    orama.documentsStore,\n    language,\n    params,\n    propertiesToSearch,\n    tokens,\n    await orama.documentsStore.count(docs),\n    timeStart,\n  )\n\n  // If filters are enabled, we need to get the IDs of the documents that match the filters.\n  const hasFilters = Object.keys(params.where ?? {}).length > 0\n  let whereFiltersIDs: InternalDocumentID[] = []\n\n  if (hasFilters) {\n    whereFiltersIDs = await orama.index.searchByWhereClause(context, index, params.where!)\n  }\n\n  const tokensLength = tokens.length\n\n  if (tokensLength) {\n    // Now it's time to loop over all the indices and get the documents IDs for every single term\n    const indexesLength = propertiesToSearch.length\n    for (let i = 0; i < indexesLength; i++) {\n      const prop = propertiesToSearch[i]\n\n      const tokensLength = tokens.length\n      for (let j = 0; j < tokensLength; j++) {\n        const term = tokens[j]\n\n        // Lookup\n        const scoreList = await orama.index.search(context, index, prop, term)\n\n        context.indexMap[prop][term].push(...scoreList)\n      }\n\n      const docIds = context.indexMap[prop]\n      const vals = Object.values(docIds)\n      context.docsIntersection[prop] = prioritizeTokenScores(vals, params?.boost?.[prop] ?? 1, threshold, tokensLength)\n      const uniqueDocs = context.docsIntersection[prop]\n\n      const uniqueDocsLength = uniqueDocs.length\n      for (let i = 0; i < uniqueDocsLength; i++) {\n        const [id, score] = uniqueDocs[i]\n        const prevScore = context.uniqueDocsIDs[id]\n        if (prevScore) {\n          context.uniqueDocsIDs[id] = prevScore + score + 0.5\n        } else {\n          context.uniqueDocsIDs[id] = score\n        }\n      }\n    }\n  } else if (tokens.length === 0 && term) {\n    // This case is hard to handle correctly.\n    // For the time being, if tokenizer returns empty array but the term is not empty,\n    // we returns an empty result set\n    context.uniqueDocsIDs = {}\n  } else {\n    context.uniqueDocsIDs = Object.fromEntries(\n      Object.keys(await orama.documentsStore.getAll(orama.data.docs)).map(k => [k, 0]),\n    )\n  }\n\n  // Get unique doc IDs from uniqueDocsIDs map\n  let uniqueDocsArray = Object.entries(context.uniqueDocsIDs).map(([id, score]) => [+id, score] as TokenScore)\n\n  // If filters are enabled, we need to remove the IDs of the documents that don't match the filters.\n  if (hasFilters) {\n    uniqueDocsArray = intersectFilteredIDs(whereFiltersIDs, uniqueDocsArray)\n  }\n\n  if (params.sortBy) {\n    if (typeof params.sortBy === 'function') {\n      const ids = uniqueDocsArray.map(([id]) => id)\n      const docs = await orama.documentsStore.getMultiple(orama.data.docs, ids)\n      const docsWithIdAndScore: CustomSorterFunctionItem[] = docs.map((d, i) => [\n        uniqueDocsArray[i][0],\n        uniqueDocsArray[i][1],\n        d!,\n      ])\n      docsWithIdAndScore.sort(params.sortBy)\n      uniqueDocsArray = docsWithIdAndScore.map(([id, score]) => [id, score])\n    } else {\n      uniqueDocsArray = await orama.sorter\n        .sortBy(orama.data.sorting, uniqueDocsArray, params.sortBy)\n        .then(results =>\n          results.map(([id, score]) => [getInternalDocumentId(orama.internalDocumentIDStore, id), score]),\n        )\n    }\n  } else {\n    uniqueDocsArray = uniqueDocsArray.sort(sortTokenScorePredicate)\n  }\n\n  let results\n  if (!isPreflight && distinctOn) {\n    results = await fetchDocumentsWithDistinct(orama, uniqueDocsArray, offset, limit, distinctOn)\n  } else if (!isPreflight) {\n    results = await fetchDocuments(orama, uniqueDocsArray, offset, limit)\n  }\n\n  const searchResult: Results<AggValue> = {\n    elapsed: {\n      formatted: '',\n      raw: 0,\n    },\n    // We keep the hits array empty if it's a preflight request.\n    hits: [],\n    count: uniqueDocsArray.length,\n  }\n\n  if (typeof results !== 'undefined') {\n    searchResult.hits = results.filter(Boolean)\n  }\n\n  if (shouldCalculateFacets) {\n    // Populate facets if needed\n    const facets = await getFacets(orama, uniqueDocsArray, params.facets!)\n    searchResult.facets = facets\n  }\n\n  if (params.groupBy) {\n    searchResult.groups = await getGroups(orama, uniqueDocsArray, params.groupBy)\n  }\n\n  if (orama.afterSearch) {\n    await runAfterSearch(orama.afterSearch, orama, params, language, searchResult)\n  }\n\n  // Calculate elapsed time only at the end of the function\n  searchResult.elapsed = (await orama.formatElapsedTime(\n    (await getNanosecondsTime()) - context.timeStart,\n  )) as ElapsedTime\n\n  return searchResult\n}\n\nasync function fetchDocumentsWithDistinct(\n  orama: Orama,\n  uniqueDocsArray: [InternalDocumentID, number][],\n  offset: number,\n  limit: number,\n  distinctOn: string,\n): Promise<Result[]> {\n  const docs = orama.data.docs\n\n  // Keep track which values we already seen\n  const values = new Map<SearchableValue, true>()\n\n  // We cannot know how many results we will have in the end,\n  // so we need cannot pre-allocate the array.\n  const results: Result[] = []\n\n  const resultIDs: Set<InternalDocumentID> = new Set()\n  const uniqueDocsArrayLength = uniqueDocsArray.length\n  let count = 0\n  for (let i = 0; i < uniqueDocsArrayLength; i++) {\n    const idAndScore = uniqueDocsArray[i]\n\n    // If there are no more results, just break the loop\n    if (typeof idAndScore === 'undefined') {\n      continue\n    }\n\n    const [id, score] = idAndScore\n\n    if (resultIDs.has(id)) {\n      continue\n    }\n\n    const doc = await orama.documentsStore.get(docs, id)\n    const value = await getNested(doc as object, distinctOn)\n    if (typeof value === 'undefined' || values.has(value)) {\n      continue\n    }\n    values.set(value, true)\n\n    count++\n    // We shouldn't consider the document if it's not in the offset range\n    if (count <= offset) {\n      continue\n    }\n\n    results.push({ id: getDocumentIdFromInternalId(orama.internalDocumentIDStore, id), score, document: doc! })\n    resultIDs.add(id)\n\n    // reached the limit, break the loop\n    if (count >= offset + limit) {\n      break\n    }\n  }\n\n  return results\n}\n\nasync function fetchDocuments(\n  orama: Orama,\n  uniqueDocsArray: [InternalDocumentID, number][],\n  offset: number,\n  limit: number,\n): Promise<Result[]> {\n  const docs = orama.data.docs\n\n  const results: Result[] = Array.from({\n    length: limit,\n  })\n\n  const resultIDs: Set<InternalDocumentID> = new Set()\n\n  // We already have the list of ALL the document IDs containing the search terms.\n  // We loop over them starting from a positional value \"offset\" and ending at \"offset + limit\"\n  // to provide pagination capabilities to the search.\n  for (let i = offset; i < limit + offset; i++) {\n    const idAndScore = uniqueDocsArray[i]\n\n    // If there are no more results, just break the loop\n    if (typeof idAndScore === 'undefined') {\n      break\n    }\n\n    const [id, score] = idAndScore\n\n    if (!resultIDs.has(id)) {\n      // We retrieve the full document only AFTER making sure that we really want it.\n      // We never retrieve the full document preventively.\n      const fullDoc = await orama.documentsStore.get(docs, id)\n      results[i] = { id: getDocumentIdFromInternalId(orama.internalDocumentIDStore, id), score, document: fullDoc! }\n      resultIDs.add(id)\n    }\n  }\n  return results\n}\n", "import { Orama } from '../types.js'\n\nexport interface RawData {\n  internalDocumentIDStore: unknown\n  index: unknown\n  docs: unknown\n  sorting: unknown\n}\n\nexport async function load(orama: Orama, raw: RawData): Promise<void> {\n  orama.internalDocumentIDStore.load(orama, raw.internalDocumentIDStore)\n  orama.data.index = await orama.index.load(orama.internalDocumentIDStore, raw.index)\n  orama.data.docs = await orama.documentsStore.load(orama.internalDocumentIDStore, raw.docs)\n  orama.data.sorting = await orama.sorter.load(orama.internalDocumentIDStore, raw.sorting)\n}\n\nexport async function save(orama: Orama): Promise<RawData> {\n  return {\n    internalDocumentIDStore: orama.internalDocumentIDStore.save(orama.internalDocumentIDStore),\n    index: await orama.index.save(orama.data.index),\n    docs: await orama.documentsStore.save(orama.data.docs),\n    sorting: await orama.sorter.save(orama.data.sorting),\n  }\n}\n", "import { runMultipleHook, runSingleHook } from '../components/hooks.js'\nimport { createError } from '../errors.js'\nimport { Document, Orama } from '../types.js'\nimport { innerInsertMultiple, insert } from './insert.js'\nimport { remove, removeMultiple } from './remove.js'\n\nexport async function update(\n  orama: Orama,\n  id: string,\n  doc: Document,\n  language?: string,\n  skipHooks?: boolean,\n): Promise<string> {\n  if (!skipHooks && orama.beforeUpdate) {\n    await runSingleHook(orama.beforeUpdate, orama, id)\n  }\n\n  await remove(orama, id, language, skipHooks)\n  const newId = await insert(orama, doc, language, skipHooks)\n\n  if (!skipHooks && orama.afterUpdate) {\n    await runSingleHook(orama.afterUpdate, orama, newId)\n  }\n\n  return newId\n}\n\nexport async function updateMultiple(\n  orama: Orama,\n  ids: string[],\n  docs: Document[],\n  batchSize?: number,\n  language?: string,\n  skipHooks?: boolean,\n): Promise<string[]> {\n  if (!skipHooks) {\n    await runMultipleHook(orama.beforeMultipleUpdate, orama, ids)\n  }\n\n  // Validate all documents before the insertion\n  const docsLength = docs.length\n  for (let i = 0; i < docsLength; i++) {\n    const errorProperty = await orama.validateSchema(docs[i], orama.schema)\n    if (errorProperty) {\n      throw createError('SCHEMA_VALIDATION_FAILURE', errorProperty)\n    }\n  }\n\n  await removeMultiple(orama, ids, batchSize, language, skipHooks)\n  const newIds = await innerInsertMultiple(orama, docs, batchSize, language, skipHooks)\n\n  if (!skipHooks) {\n    await runMultipleHook(orama.afterMultipleUpdate, orama, newIds)\n  }\n\n  return newIds\n}\n", "export { boundedLevenshtein } from './components/levenshtein.js'\nexport { formatBytes, formatNanoseconds, getNanosecondsTime, uniqueId } from './utils.js'\nexport * as radixTree from './trees/radix.js'\nexport * as avl from './trees/avl.js'\n"],
  "mappings": "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T;IACAE;EACF;AACF;AAEA,eAAsB2H,cAAqC;AACzD,SAAO;IACL9F,QAAAA;IACA4B,QAAAA;IACAc,QAAAA;IACAlF;IACAa;IACAM;IACAE;IACAC;IACA6D;IACAS;IACA4B;IACAC;IACAU,MAAAA;IACAE,MAAAA;EACF;AACF;;;AKxlBA;;;;;;ACAA,IAAME,4BAA4B;AAClC,IAAMC,0BAA0B;AAEhC,IAAMC,2BAA2B;EAC/B;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EA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",
  "names": ["STEMMERS", "arabic", "armenian", "bulgarian", "danish", "dutch", "english", "finnish", "french", "german", "greek", "hungarian", "indian", "indonesian", "irish", "italian", "lithuanian", "nepali", "norwegian", "portuguese", "romanian", "russian", "serbian", "slovenian", "spanish", "swedish", "tamil", "turkish", "ukrainian", "SPLITTERS", "SUPPORTED_LANGUAGES", "Object", "keys", "baseId", "Date", "now", "toString", "slice", "lastId", "k", "nano", "BigInt", "milli", "second", "sprintf", "template", "args", "replace", "replaceArgs", "groups", "length", "width", "rawWidth", "type", "position", "replacement", "Number", "parseInt", "shift", "toString", "padStart", "value", "padding", "precision", "split", "map", "w", "parseFloat", "toFixed", "padEnd", "formatBytes", "bytes", "decimals", "dm", "sizes", "i", "Math", "floor", "log", "k", "pow", "formatNanoseconds", "BigInt", "nano", "milli", "second", "getNanosecondsTime", "process", "hrtime", "undefined", "bigint", "performance", "now", "uniqueId", "baseId", "lastId", "getOwnProperty", "object", "property", "Object", "hasOwn", "prototype", "hasOwnProperty", "call", "sortTokenScorePredicate", "a", "b", "intersect", "arrays", "length", "i", "tmp", "set", "Map", "elem", "found", "count", "get", "filter", "e", "undefined", "getDocumentProperties", "doc", "paths", "properties", "pathsLength", "path", "pathTokens", "split", "current", "pathTokensLength", "j", "Array", "isArray", "getNested", "obj", "props", "allLanguages", "SUPPORTED_LANGUAGES", "join", "errors", "NO_LANGUAGE_WITH_CUSTOM_TOKENIZER", "LANGUAGE_NOT_SUPPORTED", "INVALID_STEMMER_FUNCTION_TYPE", "MISSING_STEMMER", "CUSTOM_STOP_WORDS_MUST_BE_FUNCTION_OR_ARRAY", "UNSUPPORTED_COMPONENT", "COMPONENT_MUST_BE_FUNCTION", "COMPONENT_MUST_BE_FUNCTION_OR_ARRAY_FUNCTIONS", "INVALID_SCHEMA_TYPE", "DOCUMENT_ID_MUST_BE_STRING", "DOCUMENT_ALREADY_EXISTS", "DOCUMENT_DOES_NOT_EXIST", "MISSING_DOCUMENT_PROPERTY", "INVALID_DOCUMENT_PROPERTY", "UNKNOWN_INDEX", "INVALID_BOOST_VALUE", "INVALID_FILTER_OPERATION", "SCHEMA_VALIDATION_FAILURE", "INVALID_SORT_SCHEMA_TYPE", "CANNOT_SORT_BY_ARRAY", "UNABLE_TO_SORT_ON_UNKNOWN_FIELD", "SORT_DISABLED", "UNKNOWN_GROUP_BY_PROPERTY", "INVALID_GROUP_BY_PROPERTY", "UNKNOWN_FILTER_PROPERTY", "createError", "code", "args", "error", "Error", "sprintf", "prototype", "captureStackTrace", "formatElapsedTime", "n", "raw", "Number", "formatted", "formatNanoseconds", "getDocumentIndexId", "doc", "id", "createError", "uniqueId", "validateSchema", "schema", "prop", "type", "Object", "entries", "value", "typeOfValue", "typeOfType", "isArrayType", "Array", "isArray", "expectedType", "getInnerType", "valueLength", "length", "i", "subProp", "undefined", "IS_ARRAY_TYPE", "string", "number", "boolean", "INNER_TYPE", "load", "save", "createInternalDocumentIDStore", "idToInternalId", "Map", "internalIdToId", "save", "load", "store", "orama", "raw", "internalDocumentIDStore", "clear", "i", "length", "set", "push", "getInternalDocumentId", "id", "internalId", "get", "currentId", "size", "toString", "getDocumentIdFromInternalId", "Error", "create", "_", "sharedInternalDocumentStore", "docs", "count", "get", "store", "id", "internalId", "getInternalDocumentId", "getMultiple", "ids", "found", "Array", "from", "length", "i", "getAll", "doc", "remove", "load", "raw", "rawDocument", "save", "createDocumentsStore", "OBJECT_COMPONENTS", "FUNCTION_COMPONENTS", "SINGLE_OR_ARRAY_COMPONENTS", "runSingleHook", "hooks", "orama", "id", "doc", "hooksLength", "length", "i", "runMultipleHook", "docsOrIds", "runAfterSearch", "db", "params", "language", "results", "create", "insert", "load", "remove", "save", "create", "remove", "BALANCE_STATE", "UNBALANCED_RIGHT", "SLIGHTLY_UNBALANCED_RIGHT", "BALANCED", "SLIGHTLY_UNBALANCED_LEFT", "UNBALANCED_LEFT", "getHeight", "node", "height", "rotateLeft", "right", "left", "Math", "max", "rotateRight", "contains", "key", "find", "getSize", "root", "size", "queue", "push", "length", "shift", "isBalanced", "stack", "pop", "undefined", "heightDiff", "rangeSearch", "min", "result", "traverse", "value", "greaterThan", "inclusive", "lessThan", "getNodeByKey", "insert", "parent", "current", "concat", "newNode", "balanceFactor", "getNodeParent", "parentNode", "minValueNode", "minValueParent", "childNode", "removeDocument", "id", "splice", "indexOf", "contains", "create", "find", "insert", "_boundedLevenshtein", "a", "b", "tolerance", "swap", "length", "lenA", "lenB", "charCodeAt", "startIdx", "delta", "i", "row", "characterCodeCache", "offset", "haveMax", "jStart", "jEnd", "current", "left", "above", "charA", "j", "boundedLevenshtein", "distance", "isBounded", "syncBoundedLevenshtein", "Node", "constructor", "key", "subWord", "end", "children", "docs", "word", "toJSON", "updateParent", "node", "parent", "addDocument", "docID", "push", "removeDocument", "index", "indexOf", "splice", "findAllWords", "output", "term", "exact", "tolerance", "docIDs", "getOwnProperty", "difference", "Math", "abs", "length", "syncBoundedLevenshtein", "isBounded", "Set", "docIDsLength", "i", "add", "Array", "from", "character", "Object", "keys", "getCommonPrefix", "a", "b", "commonPrefix", "len", "min", "create", "insert", "root", "docId", "currentCharacter", "wordAtIndex", "substring", "rootChildCurrentChar", "edgeLabel", "edgeLabelLength", "commonPrefixLength", "edgeLabelAtCommonPrefix", "newNode", "newNodeChild", "inbetweenNode", "inbetweenNodeChild", "wordAtCommonPrefix", "find", "termSubstring", "contains", "rootChildrenChar", "removeWord", "removeDocumentByWord", "prioritizeTokenScores", "arrays", "boost", "threshold", "keywordsCount", "createError", "tokenScoresMap", "Map", "tokenKeywordsCountMap", "mapsLength", "length", "i", "arr", "entriesLength", "j", "token", "score", "boostScore", "oldScore", "get", "undefined", "set", "tokenScores", "tokenScoreEntry", "entries", "push", "results", "sort", "a", "b", "allResults", "tokenKeywordsCount", "tokenKeywordsCountEntry", "keywordsPerToken", "lastTokenWithAllKeywords", "slice", "thresholdLength", "Math", "ceil", "BM25", "tf", "matchingCount", "docsCount", "fieldLength", "averageFieldLength", "BM25Params", "k", "d", "idf", "log", "insertDocumentScoreParameters", "index", "prop", "id", "tokens", "docsCount", "internalId", "getInternalDocumentId", "sharedInternalDocumentStore", "avgFieldLength", "length", "fieldLengths", "frequencies", "insertTokenScoreParameters", "token", "tokenFrequency", "t", "tf", "tokenOccurrences", "removeDocumentScoreParameters", "undefined", "removeTokenScoreParameters", "calculateResultScores", "context", "term", "ids", "documentIDs", "Array", "from", "oramaOccurrences", "oramaFrequencies", "termOccurrences", "scoreList", "documentIDsLength", "k", "bm25", "BM25", "params", "relevance", "push", "create", "orama", "schema", "prefix", "indexes", "searchableProperties", "searchablePropertiesWithTypes", "type", "Object", "entries", "typeActualType", "path", "isArray", "true", "false", "avlCreate", "radixCreate", "createError", "insertScalar", "implementation", "value", "schemaType", "language", "tokenizer", "booleanIndex", "avlInsert", "tokenize", "radixInsert", "insert", "isArrayType", "innerSchemaType", "getInnerType", "elements", "elementsLength", "i", "removeScalar", "avlRemoveDocument", "booleanKey", "position", "indexOf", "splice", "radixRemoveDocument", "remove", "search", "rootNode", "exact", "tolerance", "searchResult", "radixFind", "Set", "key", "add", "searchByWhereClause", "filters", "filterKeys", "keys", "filtersMap", "reduce", "acc", "param", "operation", "idx", "filteredIDs", "toString", "raw", "flat", "filteredIDsResults", "values", "operationKeys", "operationOpt", "operationValue", "AVLNode", "avlGreaterThan", "avlLessThan", "avlFind", "min", "max", "avlRangeSearch", "result", "intersect", "getSearchableProperties", "getSearchablePropertiesWithTypes", "loadNode", "node", "convertedNode", "end", "subWord", "docs", "word", "childrenKey", "children", "load", "rawIndexes", "save", "createIndex", "DIACRITICS_CHARCODE_START", "DIACRITICS_CHARCODE_END", "CHARCODE_REPLACE_MAPPING", "replaceChar", "charCode", "replaceDiacritics", "str", "stringCharCode", "idx", "length", "charCodeAt", "String", "fromCharCode", "step2List", "ational", "tional", "enci", "anci", "izer", "bli", "alli", "entli", "eli", "ousli", "ization", "ation", "ator", "alism", "iveness", "fulness", "ousness", "aliti", "iviti", "biliti", "logi", "step3List", "icate", "ative", "alize", "iciti", "ical", "ful", "ness", "c", "v", "C", "V", "mgr0", "meq1", "mgr1", "s_v", "stemmer", "w", "stem", "suffix", "re", "re2", "re3", "re4", "length", "firstch", "substring", "toUpperCase", "test", "replace", "fp", "exec", "RegExp", "toLowerCase", "normalizeToken", "prop", "token", "key", "language", "normalizationCache", "has", "get", "stopWords", "includes", "set", "stemmer", "stemmerSkipProperties", "replaceDiacritics", "trim", "text", "length", "pop", "shift", "tokenize", "input", "createError", "splitRule", "SPLITTERS", "tokens", "toLowerCase", "split", "map", "bind", "filter", "Boolean", "trimTokens", "allowDuplicates", "Array", "from", "Set", "createTokenizer", "config", "SUPPORTED_LANGUAGES", "stemming", "english", "isArray", "s", "tokenizer", "flat", "Map", "load", "save", "innerCreate", "orama", "sharedInternalDocumentStore", "schema", "sortableDeniedProperties", "prefix", "sorter", "language", "tokenizer", "enabled", "isSorted", "sortableProperties", "sortablePropertiesWithTypes", "sorts", "prop", "type", "Object", "entries", "typeActualType", "path", "includes", "Array", "isArray", "ret", "push", "docs", "Map", "orderedDocsToRemove", "orderedDocs", "createError", "create", "config", "isSortEnabled", "disabled", "unsortableProperties", "insert", "id", "value", "internalId", "getInternalDocumentId", "s", "set", "length", "ensureIsSorted", "properties", "keys", "ensurePropertyIsSorted", "stringSort", "d", "localeCompare", "numberSort", "booleanSort", "predicate", "bind", "sort", "orderedDocsLength", "i", "docId", "ensureOrderedDocsAreDeleted", "ensureOrderedDocsAreDeletedByProperty", "size", "filter", "doc", "has", "clear", "remove", "index", "get", "delete", "sortBy", "docIds", "by", "property", "isDesc", "order", "join", "a", "b", "indexOfA", "indexOfB", "isAIndexed", "isBIndexed", "getSortableProperties", "getSortablePropertiesWithTypes", "load", "raw", "rawDocument", "reduce", "acc", "map", "k", "v", "save", "fromEntries", "createSorter", "validateComponents", "components", "defaultComponents", "formatElapsedTime", "getDocumentIndexId", "getDocumentProperties", "validateSchema", "rawKey", "FUNCTION_COMPONENTS", "key", "createError", "SINGLE_OR_ARRAY_COMPONENTS", "component", "Array", "isArray", "fn", "Object", "keys", "OBJECT_COMPONENTS", "includes", "create", "schema", "sort", "language", "id", "uniqueId", "tokenizer", "index", "documentsStore", "sorter", "createTokenizer", "tokenize", "internalDocumentStore", "createInternalDocumentIDStore", "createIndex", "createSorter", "createDocumentsStore", "beforeInsert", "afterInsert", "beforeRemove", "afterRemove", "beforeUpdate", "afterUpdate", "afterSearch", "beforeMultipleInsert", "afterMultipleInsert", "beforeMultipleRemove", "afterMultipleRemove", "beforeMultipleUpdate", "afterMultipleUpdate", "orama", "data", "caches", "internalDocumentIDStore", "docs", "sorting", "getByID", "db", "id", "documentsStore", "get", "data", "docs", "count", "components_exports", "kInsertions", "Symbol", "kRemovals", "globalThis", "warn", "process", "emitWarning", "message", "options", "console", "code", "trackInsertion", "orama", "kInsertions", "queueMicrotask", "undefined", "trackRemoval", "kRemovals", "insert", "orama", "doc", "language", "skipHooks", "errorProperty", "validateSchema", "schema", "createError", "innerInsert", "index", "docs", "data", "id", "getDocumentIndexId", "documentsStore", "store", "docsCount", "count", "runSingleHook", "beforeInsert", "indexableProperties", "getSearchableProperties", "indexablePropertiesWithTypes", "getSearchablePropertiesWithTypes", "indexableValues", "getDocumentProperties", "key", "value", "Object", "entries", "actualType", "expectedType", "isArrayType", "Array", "isArray", "prop", "tokenizer", "afterInsert", "sortableProperties", "sorter", "getSortableProperties", "sorting", "sortablePropertiesWithTypes", "getSortablePropertiesWithTypes", "sortableValues", "trackInsertion", "insertMultiple", "batchSize", "runMultipleHook", "beforeMultipleInsert", "docsLength", "length", "i", "innerInsertMultiple", "ids", "Promise", "resolve", "reject", "_insertMultiple", "batch", "slice", "push", "err", "setTimeout", "afterMultipleInsert", "remove", "orama", "id", "language", "skipHooks", "result", "index", "docs", "data", "doc", "documentsStore", "get", "docId", "getDocumentIdFromInternalId", "internalDocumentIDStore", "getInternalDocumentId", "docsCount", "count", "runSingleHook", "beforeRemove", "indexableProperties", "getSearchableProperties", "indexablePropertiesWithTypes", "getSearchablePropertiesWithTypes", "values", "getDocumentProperties", "prop", "value", "schemaType", "tokenizer", "afterRemove", "sortableProperties", "sorter", "getSortableProperties", "sorting", "sortableValues", "trackRemoval", "removeMultiple", "ids", "batchSize", "docIdsForHooks", "map", "runMultipleHook", "beforeMultipleRemove", "Promise", "resolve", "reject", "i", "_insertMultiple", "batch", "slice", "length", "err", "setTimeout", "afterMultipleRemove", "sortingPredicate", "order", "a", "b", "toLowerCase", "getFacets", "orama", "results", "facetsConfig", "facets", "allIDs", "map", "id", "allDocs", "documentsStore", "getMultiple", "data", "docs", "facetKeys", "Object", "keys", "properties", "index", "getSearchablePropertiesWithTypes", "facet", "values", "ranges", "tmp", "range", "push", "from", "to", "fromEntries", "count", "allDocsLength", "length", "i", "doc", "facetValue", "includes", "getNested", "propertyType", "calculateNumberFacet", "alreadyInsertedValues", "Set", "v", "calculateBooleanOrStringFacet", "innerType", "stringFacetDefinition", "entries", "sort", "slice", "offset", "limit", "value", "has", "undefined", "add", "toString", "intersectFilteredIDs", "filtered", "lookedUp", "map", "Map", "result", "id", "set", "score", "has", "push", "delete", "DEFAULT_REDUCE", "reducer", "_", "acc", "res", "index", "getInitialValue", "length", "Array", "from", "ALLOWED_TYPES", "getGroups", "orama", "results", "groupBy", "properties", "propertiesLength", "schemaProperties", "getSearchablePropertiesWithTypes", "data", "i", "property", "createError", "includes", "join", "allIDs", "map", "id", "getDocumentIdFromInternalId", "internalDocumentIDStore", "allDocs", "documentsStore", "getMultiple", "docs", "allDocsLength", "returnedCount", "maxResult", "Number", "MAX_SAFE_INTEGER", "listOfValues", "g", "groupByKey", "group", "perValue", "values", "Set", "j", "doc", "value", "getNested", "keyValue", "indexes", "count", "push", "add", "combinations", "calculateCombination", "combinationsLength", "groups", "combination", "combinationLength", "intersect", "sort", "a", "b", "groupsLength", "reduce", "score", "document", "func", "bind", "initialValue", "aggregationValue", "result", "arrs", "item", "head", "c", "defaultBM25Params", "k", "b", "d", "createSearchContext", "tokenizer", "index", "documentsStore", "language", "params", "properties", "tokens", "docsCount", "timeStart", "indexMap", "docsIntersection", "prop", "tokensMap", "token", "uniqueDocsIDs", "search", "orama", "getNanosecondsTime", "relevance", "Object", "assign", "shouldCalculateFacets", "facets", "keys", "length", "limit", "offset", "term", "threshold", "distinctOn", "isPreflight", "preflight", "docs", "data", "tokenize", "propertiesToSearch", "caches", "propertiesToSearchWithTypes", "getSearchablePropertiesWithTypes", "getSearchableProperties", "filter", "startsWith", "includes", "createError", "join", "context", "count", "hasFilters", "where", "whereFiltersIDs", "searchByWhereClause", "tokensLength", "indexesLength", "i", "j", "scoreList", "push", "docIds", "vals", "values", "prioritizeTokenScores", "boost", "uniqueDocs", "uniqueDocsLength", "id", "score", "prevScore", "fromEntries", "getAll", "map", "uniqueDocsArray", "entries", "intersectFilteredIDs", "sortBy", "ids", "getMultiple", "docsWithIdAndScore", "sort", "sorter", "sorting", "then", "results", "getInternalDocumentId", "internalDocumentIDStore", "sortTokenScorePredicate", "fetchDocumentsWithDistinct", "fetchDocuments", "searchResult", "elapsed", "formatted", "raw", "hits", "Boolean", "getFacets", "groupBy", "groups", "getGroups", "afterSearch", "runAfterSearch", "formatElapsedTime", "Map", "resultIDs", "Set", "uniqueDocsArrayLength", "idAndScore", "has", "doc", "get", "value", "getNested", "set", "getDocumentIdFromInternalId", "document", "add", "Array", "from", "fullDoc", "load", "orama", "raw", "internalDocumentIDStore", "data", "index", "docs", "documentsStore", "sorting", "sorter", "save", "update", "orama", "id", "doc", "language", "skipHooks", "beforeUpdate", "runSingleHook", "remove", "newId", "insert", "afterUpdate", "updateMultiple", "ids", "docs", "batchSize", "runMultipleHook", "beforeMultipleUpdate", "docsLength", "length", "i", "errorProperty", "validateSchema", "schema", "createError", "removeMultiple", "newIds", "innerInsertMultiple", "afterMultipleUpdate"]
}
